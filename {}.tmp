//
//  AuthViewModel.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import Foundation
import CoreData
import CryptoKit
class AuthViewModel: ObservableObject {
    @Published var user: User?
    @Published var error: String?
    @Published var isLoading = false
    private let context: NSManagedObjectContext
    init(context: NSManagedObjectContext) {
        self.context = context
    }
    @MainActor
    func signUp(username: String, password: String) async {
        print("AuthViewModel: Starting sign up for username: \(username)")
        guard !username.isEmpty, !password.isEmpty else {
            error = "Username and password cannot be empty"
            print("AuthViewModel: Validation failed - empty username or password")
            return
        }
        guard username.count >= 3 else {
            error = "Username must be at least 3 characters long"
            print("AuthViewModel: Validation failed - username too short")
            return
        }
        guard password.count >= 6 else {
            error = "Password must be at least 6 characters long"
            print("AuthViewModel: Validation failed - password too short")
            return
        }
        isLoading = true
        error = nil
        do {
            print("AuthViewModel: Checking for existing users")
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "username == %@", username)
            let existingUsers = try context.fetch(fetchRequest)
            if !existingUsers.isEmpty {
                error = "Username already taken"
                isLoading = false
                print("AuthViewModel: Username already taken")
                return
            }
            print("AuthViewModel: Creating new user entity")
            let userEntity = UserEntity(context: context)
            userEntity.id = UUID().uuidString
            userEntity.username = username
            userEntity.password = hashPassword(password)
            userEntity.updates = 0
            userEntity.level = "Newbie"
            userEntity.createdAt = Date()
            print("AuthViewModel: Saving context")
            try context.save()
            user = User(
                id: userEntity.id ?? UUID().uuidString,
                username: username,
                updates: Int(userEntity.updates)
            )
            // Store the current username for the social feed
            UserDefaults.standard.set(username, forKey: "currentUsername")
            error = nil
            print("AuthViewModel: Sign up successful")
        } catch {
            self.error = "Failed to sign up: \(error.localizedDescription)"
            print("AuthViewModel: Sign up failed with error: \(error)")
        }
        isLoading = false
    }
    @MainActor
    func login(username: String, password: String) async {
        print("AuthViewModel: Starting login for username: \(username)")
        guard !username.isEmpty, !password.isEmpty else {
            error = "Username and password cannot be empty"
            print("AuthViewModel: Validation failed - empty username or password")
            return
        }
        isLoading = true
        error = nil
        do {
            print("AuthViewModel: Fetching user from Core Data")
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "username == %@", username)
            let users = try context.fetch(fetchRequest)
            if let userEntity = users.first {
                print("AuthViewModel: User found, checking password")
                let hashedPassword = hashPassword(password)
                if userEntity.password == hashedPassword {
                    user = User(
                        id: userEntity.id ?? UUID().uuidString,
                        username: username,
                        updates: Int(userEntity.updates)
                    )
                    // Store the current username for the social feed
                    UserDefaults.standard.set(username, forKey: "currentUsername")
                    error = nil
                    print("AuthViewModel: Login successful")
                } else {
                    error = "Invalid username or password"
                    print("AuthViewModel: Password mismatch")
                }
            } else {
                error = "Invalid username or password"
                print("AuthViewModel: User not found")
            }
        } catch {
            self.error = "Login failed: \(error.localizedDescription)"
            print("AuthViewModel: Login failed with error: \(error)")
        }
        isLoading = false
    }
    func logout() {
        user = nil
        error = nil
        // Clear the current username when logging out
        UserDefaults.standard.removeObject(forKey: "currentUsername")
    }
    private func hashPassword(_ password: String) -> String {
        let inputData = Data(password.utf8)
        let hashed = SHA256.hash(data: inputData)
        return hashed.compactMap { String(format: "%02x", $0) }.joined()
    }
}
//
//  SocialFeedViewModel.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
import SwiftUI
@MainActor
class SocialFeedViewModel: ObservableObject {
    @Published var experiences: [ShoppingExperience] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    private let persistenceController = PersistenceController.shared
    init() {
        loadExperiences()
    }
    // MARK: - Public Methods
    func loadExperiences() {
        isLoading = true
        errorMessage = nil
        let context = persistenceController.container.viewContext
        let request: NSFetchRequest<ShoppingExperience> = ShoppingExperience.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \ShoppingExperience.createdAt, ascending: false)]
        do {
            experiences = try context.fetch(request)
            isLoading = false
        } catch {
            errorMessage = "Failed to load experiences: \(error.localizedDescription)"
            isLoading = false
        }
    }
    func createExperience(comment: String, rating: Int16 = 0, type: String = "general", groceryItem: GroceryItem? = nil, location: Location? = nil, user: UserEntity? = nil) {
        let context = persistenceController.container.viewContext
        // Ensure all objects are in the same context
        let contextGroceryItem: GroceryItem?
        let contextLocation: Location?
        let contextUser: UserEntity?
        if let groceryItem = groceryItem {
            contextGroceryItem = context.object(with: groceryItem.objectID) as? GroceryItem
            print("GroceryItem context conversion: \(groceryItem.managedObjectContext?.description ?? "nil") -> \(contextGroceryItem?.managedObjectContext?.description ?? "nil")")
        } else {
            contextGroceryItem = nil
        }
        if let location = location {
            contextLocation = context.object(with: location.objectID) as? Location
            print("Location context conversion: \(location.managedObjectContext?.description ?? "nil") -> \(contextLocation?.managedObjectContext?.description ?? "nil")")
        } else {
            contextLocation = nil
        }
        if let user = user {
            contextUser = context.object(with: user.objectID) as? UserEntity
            print("User context conversion: \(user.managedObjectContext?.description ?? "nil") -> \(contextUser?.managedObjectContext?.description ?? "nil")")
        } else {
            contextUser = nil
        }
        let experience = ShoppingExperience(
            context: context,
            id: UUID().uuidString,
            comment: comment,
            rating: rating,
            type: type,
            user: contextUser,
            groceryItem: contextGroceryItem,
            location: contextLocation
        )
        do {
            try context.save()
            loadExperiences() // Refresh the feed
        } catch {
            print("Core Data save error: \(error)")
            errorMessage = "Failed to create experience: \(error.localizedDescription)"
        }
    }
    func createComment(comment: String, rating: Int16 = 0, experience: ShoppingExperience, user: UserEntity? = nil) {
        let context = persistenceController.container.viewContext
        // Ensure all objects are in the same context
        let contextExperience = context.object(with: experience.objectID) as? ShoppingExperience
        let contextUser: UserEntity?
        if let user = user {
            contextUser = context.object(with: user.objectID) as? UserEntity
        } else {
            contextUser = nil
        }
        let userComment = UserComment(
            context: context,
            id: UUID().uuidString,
            comment: comment,
            rating: rating,
            user: contextUser,
            experience: contextExperience
        )
        do {
            try context.save()
            loadExperiences() // Refresh the feed
        } catch {
            print("Core Data save error: \(error)")
            errorMessage = "Failed to create comment: \(error.localizedDescription)"
        }
    }
    func createPriceUpdateExperience(groceryItem: GroceryItem, location: Location, price: Double, user: UserEntity? = nil) {
        let comment = "Price updated to $\(String(format: "%.2f", price)) at \(location.name ?? "Unknown Store")"
        createExperience(
            comment: comment,
            rating: 0,
            type: "price_update",
            groceryItem: groceryItem,
            location: location,
            user: user
        )
    }
    func createStoreReviewExperience(location: Location, comment: String, rating: Int16, user: UserEntity? = nil) {
        createExperience(
            comment: comment,
            rating: rating,
            type: "store_review",
            location: location,
            user: user
        )
    }
    func createProductReviewExperience(groceryItem: GroceryItem, comment: String, rating: Int16, user: UserEntity? = nil) {
        createExperience(
            comment: comment,
            rating: rating,
            type: "product_review",
            groceryItem: groceryItem,
            user: user
        )
    }
    func createGeneralExperience(comment: String, user: UserEntity? = nil) {
        createExperience(
            comment: comment,
            rating: 0,
            type: "general",
            user: user
        )
    }
    // MARK: - Helper Methods
    func formatDate(_ date: Date?) -> String {
        guard let date = date else { return "Unknown" }
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    func formatRating(_ rating: Int16) -> String {
        return String(repeating: "⭐", count: Int(rating))
    }
    func getCurrentUser() -> UserEntity? {
        let context = persistenceController.container.viewContext
        let request: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
        // Get the current username from UserDefaults
        let currentUsername = UserDefaults.standard.string(forKey: "currentUsername")
        if let username = currentUsername {
            // Find the user with the current username
            request.predicate = NSPredicate(format: "username == %@", username)
        } else {
            // Fallback to the most recently created user
            request.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            request.fetchLimit = 1
        }
        do {
            let users = try context.fetch(request)
            let user = users.first
            print("getCurrentUser: Found user \(user?.username ?? "nil") in context \(user?.managedObjectContext?.description ?? "nil")")
            return user
        } catch {
            print("getCurrentUser error: \(error)")
            return nil
        }
    }
}
//
//  ProductViewModel.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import SwiftUI
import Combine
import CoreData
import Foundation
@MainActor
final class ProductViewModel: ObservableObject {
    @Published var products: [GroceryItem] = []
    @Published var favoriteProducts: [GroceryItem] = []
    @Published var recentProducts: [GroceryItem] = []
    @Published var priceComparison: PriceComparison?
    @Published var isLoadingPriceComparison = false
    @Published var tags: [Tag] = []
    @Published var locations: [Location] = []
    var errorMessage: String?
    private let repository: ProductRepositoryProtocol
    private let imageService: ImageServiceProtocol
    // Computed property to check if all products are completed
    var allProductsCompleted: Bool {
        !products.isEmpty && products.allSatisfy { $0.isCompleted }
    }
    init(repository: ProductRepositoryProtocol, imageService: ImageServiceProtocol = ImageService()) {
        self.repository = repository
        self.imageService = imageService
        Task {
            await loadTags()
        }
    }
    func loadShoppingListProducts() async {
        do {
            products = try await repository.fetchListProducts()
            // Filter out any orphaned price relationships from deleted locations at render time via model helpers

            // Fetch images for products that don't have them
            await fetchImagesForProducts()

            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func loadProducts() async {
        do {
            products = try await repository.fetchAllProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Fetch all products without mutating the published `products` array
    // Useful for views that need a read-only snapshot without triggering UI-wide reloads
    func fetchAllProducts() async -> [GroceryItem] {
        do {
            return try await repository.fetchAllProducts()
        } catch {
            // Surface the error but do not mutate state; return an empty list on failure
            errorMessage = error.localizedDescription
            return []
        }
    }
    func updateProduct(_ product: GroceryItem) async {
        do {
            try await repository.updateProduct(product)
            await loadProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Update a product without reloading the entire products list (prevents visible reloads)
    func updateProductQuiet(_ product: GroceryItem) async {
        do {
            try await repository.updateProduct(product)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Update product price using repository pipeline that also updates reputation
    func updateProductPrice(_ product: GroceryItem, price: Double, store: String, locationAddress: String?) async {
        do {
            try await repository.updateProductWithPrice(product: product, price: price, store: store, location: locationAddress)
            // Also create a social feed entry for this price update
            await createSocialFeedEntryForPriceUpdate(product: product, price: price, store: store, locationAddress: locationAddress)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // MARK: - Social Feed
    private func createSocialFeedEntryForPriceUpdate(product: GroceryItem, price: Double, store: String, locationAddress: String?) async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Refresh objects in context
            let productObjectID = product.objectID
            guard let productInContext = try? context.existingObject(with: productObjectID) as? GroceryItem else { return }
            // Find or create the location by store name/address (best-effort lookup)
            let locationFetch: NSFetchRequest<Location> = Location.fetchRequest()
            if let locationAddress = locationAddress, !locationAddress.isEmpty {
                locationFetch.predicate = NSPredicate(format: "name == %@ AND address == %@", store, locationAddress)
            } else {
                locationFetch.predicate = NSPredicate(format: "name == %@", store)
            }
            locationFetch.fetchLimit = 1
            let locations = try context.fetch(locationFetch)
            let locationInContext = locations.first
            // Current user
            let userFetch: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            userFetch.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            userFetch.fetchLimit = 1
            guard let currentUser = try context.fetch(userFetch).first else { return }
            let comment = String(format: "Price updated: %@ is now $%.2f at %@", productInContext.productName ?? "Product", price, store)
            _ = ShoppingExperience(
                context: context,
                id: UUID().uuidString,
                comment: comment,
                rating: 0,
                type: "price_update",
                user: currentUser,
                groceryItem: productInContext,
                location: locationInContext
            )
            try context.save()
        } catch {
            // Non-fatal; skip if feed creation fails
        }
    }
    func deleteProduct(_ product: GroceryItem) async {
        do {
            try await repository.deleteProduct(product)
            products.removeAll { $0.id == product.id }
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func removeProductFromShoppingList(_ product: GroceryItem) async {
        do {
            try await repository.removeProductFromShoppingList(product)

            // Update the products array on the main thread
            await MainActor.run {
                products.removeAll { $0.id == product.id }
            }
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func permanentlyDeleteProduct(_ product: GroceryItem) async {
        do {
            try await repository.deleteProduct(product)
            // Reload the entire list instead of manually removing items
            // This prevents collection view inconsistency during animations
            await loadShoppingListProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func toggleProductCompletion(_ product: GroceryItem) async {
        do {
            try await repository.toggleProductCompletion(product)
            await loadShoppingListProducts() // Refresh the list to show updated completion status
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func toggleAllProductsCompletion() async {
        do {
            // Check if all products are completed
            let allCompleted = products.allSatisfy { $0.isCompleted }
            // If all are completed, uncheck them all. Otherwise, check them all.
            for product in products {
                if allCompleted {
                    // Uncheck all if all are completed
                    if product.isCompleted {
                        try await repository.toggleProductCompletion(product)
                    }
                } else {
                    // Check all if not all are completed
                    if !product.isCompleted {
                        try await repository.toggleProductCompletion(product)
                    }
                }
            }
            await loadShoppingListProducts() // Refresh the list
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    func clearShoppingList() async {
        do {
            // Remove all products from shopping list without deleting the actual product data
            for product in products {
                try await repository.removeProductFromShoppingList(product)
            }
            // Clear the local products array
            await MainActor.run {
                products.removeAll()
            }
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func addExistingProductToShoppingList(_ product: GroceryItem) async {
        do {
            try await repository.addProductToShoppingList(product)
            // Refresh shopping list to show the newly added item
            await loadShoppingListProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Quiet version that doesn't reload lists - for UI components
    func addExistingProductToShoppingListQuiet(_ product: GroceryItem) async {
        do {
            try await repository.addProductToShoppingList(product)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    // MARK: - Favorites Methods
    func loadFavoriteProducts() async {
        do {
            favoriteProducts = try await repository.fetchFavoriteProducts()

            // Fetch images for favorite products that don't have them
            await fetchImagesForProductArray(favoriteProducts)

            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func addProductToFavorites(_ product: GroceryItem) async {
        do {
            try await repository.addProductToFavorites(product)
            await loadFavoriteProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Quiet version that doesn't reload lists - for UI components
    func addProductToFavoritesQuiet(_ product: GroceryItem) async {
        do {
            try await repository.addProductToFavorites(product)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func removeProductFromFavorites(_ product: GroceryItem) async {
        do {
            try await repository.removeProductFromFavorites(product)
            await loadFavoriteProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Quiet version that doesn't reload lists - for UI components
    func removeProductFromFavoritesQuiet(_ product: GroceryItem) async {
        do {
            try await repository.removeProductFromFavorites(product)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func toggleProductFavorite(_ product: GroceryItem) async {
        do {
            try await repository.toggleProductFavorite(product)
            await loadFavoriteProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    func isProductInFavorites(_ product: GroceryItem) async -> Bool {
        do {
            let favorites = try await repository.fetchFavoriteProducts()
            return favorites.contains { favorite in
                favorite.id == product.id
            }
        } catch {
            return false
        }
    }

    // Image Fetching
    // Fetches images for products that don't have image URLs
    func fetchImagesForProducts() async {
        await fetchImagesForProductArray(products)
    }

    // Fetches images for any array of products that don't have image URLs
    private func fetchImagesForProductArray(_ productArray: [GroceryItem]) async {
        // Get products that don't have image URLs
        let productsWithoutImages = productArray.filter { $0.imageURL == nil || $0.imageURL?.isEmpty == true }

        if productsWithoutImages.isEmpty {
            return
        }

        // Fetch images for each product
        for product in productsWithoutImages {
            await fetchImageForProduct(product)
        }
    }

    // Fetches image for a specific product
    private func fetchImageForProduct(_ product: GroceryItem) async {
        do {
            let productName = product.productName ?? ""
            let brand = product.brand
            let category = product.category

            if let imageURL = try await imageService.fetchImageURL(for: productName, brand: brand, category: category) {
                // Download image data
                if let url = URL(string: imageURL) {
                    let (imageData, _) = try await URLSession.shared.data(from: url)

                    // Update product with image data on main thread
                    await MainActor.run {
                        // Save image to Core Data using new ProductImage entity
                        Task {
                            do {
                                try await repository.saveProductImage(for: product, imageURL: imageURL, imageData: imageData)

                                // Force a UI update by triggering objectWillChange
                                self.objectWillChange.send()
                            } catch {
                                print("ProductViewModel: Error saving image data: \(error.localizedDescription)")
                            }
                        }
                    }
                }
            }

        } catch {
            print("ProductViewModel: Error fetching image for '\(product.productName ?? "")': \(error.localizedDescription)")
        }
    }

    func searchProducts(by name: String) async {
        do {
            products = try await repository.searchProducts(by: name)
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }

    // Search without mutating the published `products` array
    func searchProductsQuiet(by name: String) async -> [GroceryItem] {
        do {
            return try await repository.searchProducts(by: name)
        } catch {
            errorMessage = error.localizedDescription
            return []
        }
    }
    func searchProductsByBarcode(_ barcode: String) async throws -> [GroceryItem] {
        return try await repository.searchProductsByBarcode(barcode)
    }
    func createProductForShoppingList(byName name: String, brand: String? = nil, category: String? = nil, isOnSale: Bool = false) async {
        do {
            if await isDuplicateProduct(name: name) {
                errorMessage = "Product '\(name)' already exists in your list"
                return
            }
            let id = UUID().uuidString
            // Capture the created product to fetch its image
            let savedProduct = try await repository.createProduct(
                id: id,
                productName: name,
                brand: brand,
                category: category,
                price: 0.0, // Default price - will be stored in GroceryItemPrice if > 0
                currency: "USD",
                store: nil,
                location: nil,
                imageURL: nil,
                barcode: nil,
                isInShoppingList: true,
                isOnSale: isOnSale
            )

            // Fetch image for the newly created product
            await fetchImageForProduct(savedProduct)

            await loadShoppingListProducts()
            errorMessage = nil
        } catch {
            errorMessage = error.localizedDescription
        }
    }
    // For creating products to database
    func isDuplicateProduct(name: String) async -> Bool {
        do {
            let existingProducts = try await repository.searchProducts(by: name)
            return existingProducts.contains { product in
                product.productName?.lowercased() == name.lowercased()
            }
        } catch {
            return false // If search fails, allow creation
        }
    }
    // For checking if existing product is already in shopping list
    func isProductInShoppingList(name: String) async -> Bool {
        do {
            // Only check shopping list products, not all products
            let shoppingListProducts = try await repository.fetchListProducts()
            return shoppingListProducts.contains { product in
                product.productName?.lowercased() == name.lowercased()
            }
        } catch {
            return false // If search fails, allow adding
        }
    }
    func isDuplicateBarcode(_ barcode: String) async -> Bool {
        do {
            let existingProducts = try await repository.searchProductsByBarcode(barcode)
            return existingProducts.contains { product in
                product.barcode?.lowercased() == barcode.lowercased()
            }
        } catch {
            return false // If search fails, allow creation
        }
    }
    func createProductByBarcode(
        barcode: String,
        productName: String,
        brand: String?,
        category: String?,
        price: Double,
        store: String,
        isOnSale: Bool = false
    ) async -> GroceryItem? {
        do {
            print("ProductViewModel: Creating product with barcode: \(barcode)")
            print("ProductViewModel: Store value: '\(store)'")
            // Check if product already exists with this barcode
            if await isDuplicateBarcode(barcode) {
                errorMessage = "Product with barcode '\(barcode)' already exists"
                return nil
            }
            let id = UUID().uuidString
            // Capture the created product to fetch its image
            let savedProduct = try await repository.createProduct(
                id: id,
                productName: productName,
                brand: brand,
                category: category,
                price: price,
                currency: "USD",
                store: store, // Set store for price comparison
                location: nil,
                imageURL: nil,
                barcode: barcode,
                isInShoppingList: false, // Don't automatically add to shopping list
                isOnSale: isOnSale
            )
            print("ProductViewModel: Product created successfully")
            print("ProductViewModel: Saved product store: '\(savedProduct.store ?? "nil")'")

            // Fetch image for the newly created product
            await fetchImageForProduct(savedProduct)

            await loadShoppingListProducts()
            errorMessage = nil
            return savedProduct
        } catch {
            errorMessage = error.localizedDescription
            return nil
        }
    }
    func updateProductByBarcode(barcode: String, productName: String?, brand: String?, category: String?, price: Double?, store: String?, isOnSale: Bool?) async -> GroceryItem? {
        do {
            print("ProductViewModel: Updating product with barcode: \(barcode)")
            print("ProductViewModel: Update store value: '\(store ?? "nil")'")
            let existingProducts = try await repository.searchProductsByBarcode(barcode)
            guard let existingProduct = existingProducts.first(where: { $0.barcode?.lowercased() == barcode.lowercased() }) else {
                // This should not happen if we checked isDuplicateBarcode first
                // But handle gracefully just in case
                errorMessage = "Unable to update product with barcode '\(barcode)' - product not found in database"
                return nil
            }
            print("ProductViewModel: Found existing product, current store: '\(existingProduct.store ?? "nil")'")
            // Update only provided values
            if let productName = productName {
                existingProduct.productName = productName
            }
            if let brand = brand {
                existingProduct.brand = brand
            }
            if let category = category {
                existingProduct.category = category
            }
            if let isOnSale = isOnSale {
                existingProduct.isOnSale = isOnSale
            }
            // Handle price and store updates
            if let price = price, let store = store, price > 0 {
                try await repository.updateProductWithPrice(product: existingProduct, price: price, store: store, location: nil)
            } else {
                // Just update the product without price changes
                try await repository.updateProduct(existingProduct)
            }
            print("ProductViewModel: Product updated successfully")
            print("ProductViewModel: Final product store: '\(existingProduct.store ?? "nil")'")
            await loadShoppingListProducts()
            errorMessage = nil
            return existingProduct
        } catch {
            errorMessage = error.localizedDescription
            return nil
        }
    }
    func loadLocalPriceComparison() async {
        // Get the current shopping list products specifically
        let shoppingListProducts = try? await repository.fetchListProducts()
        print("ProductViewModel: Starting local price comparison")
        print("ProductViewModel: Shopping list products count: \(shoppingListProducts?.count ?? 0)")
        guard let shoppingList = shoppingListProducts, !shoppingList.isEmpty else {
            print("ProductViewModel: No shopping list products found")
            await MainActor.run {
                priceComparison = nil
            }
            return
        }
        // Print details of each shopping list item
        for (index, item) in shoppingList.enumerated() {
            print("ProductViewModel: Item \(index + 1): \(item.productName ?? "Unknown") - Store: \(item.store ?? "None") - Price: $\(item.price)")
        }
        await MainActor.run {
            isLoadingPriceComparison = true
            errorMessage = nil
        }
        do {
            print("ViewModel: Starting local price comparison for shopping list with \(shoppingList.count) items")
            // Use the repository to get local price comparison
            let localComparison = try await repository.getLocalPriceComparison(for: shoppingList)
            print("ProductViewModel: Local comparison result - \(localComparison.storePrices.count) stores")
            for storePrice in localComparison.storePrices {
                print("ProductViewModel: Store \(storePrice.store): $\(storePrice.totalPrice)")
            }
            // Convert LocalPriceComparisonResult to PriceComparison for compatibility
            let storePrices = localComparison.storePrices.map { localStorePrice in
                StorePrice(
                    store: localStorePrice.store, // Now using String directly
                    totalPrice: localStorePrice.totalPrice,
                    currency: localStorePrice.currency,
                    availableItems: localStorePrice.availableItems,
                    unavailableItems: localStorePrice.unavailableItems,
                    itemPrices: localStorePrice.itemPrices,
                    itemShoppers: localStorePrice.itemShoppers
                )
            }
            let comparison = PriceComparison(
                storePrices: storePrices,
                bestStore: localComparison.bestStore, // Now using String directly
                bestTotalPrice: localComparison.bestTotalPrice,
                bestCurrency: localComparison.bestCurrency,
                totalItems: localComparison.totalItems,
                availableItems: localComparison.availableItems
            )
            await MainActor.run {
                priceComparison = comparison
                print("ViewModel: Local price comparison loaded successfully")
            }
        } catch {
            await MainActor.run {
                print("ViewModel: Error loading local price comparison: \(error)")
                errorMessage = "Failed to load local price comparison: \(error.localizedDescription)"
            }
        }
        await MainActor.run {
            isLoadingPriceComparison = false
        }
    }
}
extension ProductViewModel {
    @MainActor
    func loadTags() async {
        do {
            tags = try await repository.fetchAllTags()
        } catch {
            tags = []
        }
    }
    @MainActor
    func fetchAllTags() async -> [Tag] {
        do {
            return try await repository.fetchAllTags()
        } catch {
            return []
        }
    }
    @MainActor
    func addTagsToProduct(_ product: GroceryItem, tags: [Tag]) async {
        do {
            try await repository.addTagsToProduct(product, tags: tags)
        } catch {
            // Optionally handle error
        }
    }

    @MainActor
    func replaceTagsForProduct(_ product: GroceryItem, tags: [Tag]) async {
        do {
            try await repository.replaceTagsForProduct(product, tags: tags)
        } catch {
            // Optionally handle error
        }
    }
    // MARK: - Location Management
    @MainActor
    func loadLocations() async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Get current user
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try context.fetch(fetchRequest)
            guard let currentUser = users.first else { return }
            // Fetch user's locations
            let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
            locationFetchRequest.predicate = NSPredicate(format: "user == %@", currentUser)
            locationFetchRequest.sortDescriptors = [
                NSSortDescriptor(keyPath: \Location.isDefault, ascending: false),
                NSSortDescriptor(keyPath: \Location.favorited, ascending: false),
                NSSortDescriptor(keyPath: \Location.name, ascending: true)
            ]
            let fetchedLocations = try context.fetch(locationFetchRequest)
            // Update on main thread since we're already @MainActor
            self.locations = fetchedLocations
        } catch {
            print("Error loading locations: \(error)")
            self.locations = []
        }
    }
}
// This code was generated with the help of Claude, saving me 1 hour of research and development.
//
//  ImageService.swift
//  CartWise
//
//  Created by Kelly Yong on 8/4/25.
//  Enhanced with AI assistance from Cursor AI for UI improvements and functionality.
//

import Foundation
import SwiftUI
import UIKit

protocol ImageServiceProtocol {
    func fetchImageURL(for productName: String, brand: String?, category: String?) async throws -> String?
    func loadImage(from url: URL) async throws -> UIImage?
}

class ImageService: ImageServiceProtocol {
    private let networkService: NetworkService

    init(networkService: NetworkService = NetworkService()) {
        self.networkService = networkService
    }
    // Fetches image URL for a product from Amazon API
    func fetchImageURL(for productName: String, brand: String? = nil, category: String? = nil) async throws -> String? {
        do {
            // Build search query with available information
            var searchQuery = productName

            // Add brand if available
            if let brand = brand, !brand.isEmpty {
                searchQuery += " \(brand)"
            }

            // Add category if available
            if let category = category, !category.isEmpty {
                searchQuery += " \(category)"
            }

            print("ImageService: Searching for image with query: '\(searchQuery)'")
            let amazonProducts = try await networkService.searchProductsOnAmazon(by: searchQuery)
            return amazonProducts.first?.image
        } catch {
            print("ImageService: Error fetching image for '\(productName)': \(error.localizedDescription)")
            throw error
        }
    }

    // Loads image data from URL
    func loadImage(from url: URL) async throws -> UIImage? {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            return UIImage(data: data)
        } catch {
            print("ImageService: Error loading image from \(url): \(error.localizedDescription)")
            throw error
        }
    }
}
//
//  APIService.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/10/25.
//
import Foundation
import CoreData
protocol NetworkServiceProtocol: Sendable {
    func fetchProduct(by name: String) async throws -> APIProduct?
    func searchProducts(by name: String) async throws -> [APIProduct]
    func searchProductsOnAmazon(by query: String) async throws -> [APIProduct]
    func searchProductsOnWalmart(by query: String) async throws -> [APIProduct]
    func fetchProductWithRetry(by name: String, retries: Int) async throws -> APIProduct?
    func searchGroceryPrice(productName: String, store: Store) async throws -> APIProduct?
}
enum Store: String, CaseIterable, Codable {
    case amazon = "Amazon"
    case walmart = "Walmart"
    var endpoint: String {
        switch self {
        case .amazon:
            return "amazon"
        case .walmart:
            return "walmart"
        }
    }
}
final class NetworkService: NetworkServiceProtocol, @unchecked Sendable {
    private let session: URLSession
    private let baseURL = "https://api-to-find-grocery-prices.p.rapidapi.com"
    private let apiKey = "84e64a5488msh5075a47a5c27140p17850bjsnb78c0cf33881"
    init(session: URLSession = .shared) {
        self.session = session
    }
    func searchProducts(by name: String) async throws -> [APIProduct] {
        let url = try buildSearchURL(for: name)
        let response = try await performRequest(url: url, responseType: APIResponse.self)
        return response.products
    }
    func searchProductsOnAmazon(by query: String) async throws -> [APIProduct] {
        let url = try buildStoreSearchURL(for: query, store: .amazon)
        let response = try await performRequest(url: url, responseType: APIResponse.self)
        return response.products
    }
    func searchProductsOnWalmart(by query: String) async throws -> [APIProduct] {
        let url = try buildStoreSearchURL(for: query, store: .walmart)
        let response = try await performRequest(url: url, responseType: APIResponse.self)
        return response.products
    }
    func searchGroceryPrice(productName: String, store: Store) async throws -> APIProduct? {
        let url = try buildStoreSearchURL(for: productName, store: store)
        let response = try await performRequest(url: url, responseType: APIResponse.self)
        // Return the first product from the API response
        return response.products.first
    }
    func fetchProduct(by name: String) async throws -> APIProduct? {
        // For grocery prices API, we search by name and return the first result
        let products = try await searchProducts(by: name)
        return products.first
    }
    func fetchProductWithRetry(by name: String, retries: Int = 3) async throws -> APIProduct? {
        var lastError: Error?
        for attempt in 1...retries {
            do {
                return try await fetchProduct(by: name)
            } catch {
                lastError = error
                if attempt < retries {
                    try await Task.sleep(nanoseconds: UInt64(pow(2.0, Double(attempt))) * 1_000_000_000) // Exponential backoff
                }
            }
        }
        throw lastError ?? NetworkError.maxRetriesExceeded
    }
    // MARK: - Private Methods
    private func buildSearchURL(for name: String) throws -> URL {
        var components = URLComponents(string: "\(baseURL)/search")!
        components.queryItems = [
            URLQueryItem(name: "query", value: name)
        ]
        guard let url = components.url else {
            throw NetworkError.invalidURL
        }
        return url
    }
    private func buildStoreSearchURL(for query: String, store: Store) throws -> URL {
        var components = URLComponents(string: "\(baseURL)/\(store.endpoint)")!
        components.queryItems = [
            URLQueryItem(name: "query", value: query)
        ]
        guard let url = components.url else {
            throw NetworkError.invalidURL
        }
        return url
    }
    private func performRequest<T: Decodable>(url: URL, responseType: T.Type) async throws -> T {
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 30)
        // Add RapidAPI headers
        request.setValue(apiKey, forHTTPHeaderField: "X-RapidAPI-Key")
        request.setValue("api-to-find-grocery-prices.p.rapidapi.com", forHTTPHeaderField: "X-RapidAPI-Host")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        let (data, response) = try await session.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        // Debug: Print raw response
        if let jsonString = String(data: data, encoding: .utf8) {
            print("APIService: Raw JSON response: \(jsonString)")
        }
        switch httpResponse.statusCode {
        case 200:
            do {
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .convertFromSnakeCase
                return try decoder.decode(responseType, from: data)
            } catch {
                print("APIService: Decoding error: \(error)")
                throw NetworkError.decodingError(error)
            }
        case 404:
            throw NetworkError.productNotFound
        case 429:
            throw NetworkError.rateLimitExceeded
        case 500...599:
            throw NetworkError.serverError(httpResponse.statusCode)
        default:
            throw NetworkError.httpError(httpResponse.statusCode)
        }
    }
}
// MARK: - Enhanced Error Handling
enum NetworkError: Error, LocalizedError, Sendable {
    case invalidURL
    case invalidResponse
    case noData
    case productNotFound
    case rateLimitExceeded
    case serverError(Int)
    case httpError(Int)
    case decodingError(Error)
    case maxRetriesExceeded
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .invalidResponse:
            return "Invalid response from server"
        case .noData:
            return "No data received"
        case .productNotFound:
            return "Product not found"
        case .rateLimitExceeded:
            return "Rate limit exceeded. Please try again later."
        case .serverError(let code):
            return "Server error (\(code))"
        case .httpError(let code):
            return "HTTP error (\(code))"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .maxRetriesExceeded:
            return "Maximum retry attempts exceeded"
        }
    }
    var recoverySuggestion: String? {
        switch self {
        case .productNotFound:
            return "The product with this barcode was not found in the database."
        case .rateLimitExceeded:
            return "Please wait a moment before trying again."
        case .serverError, .httpError:
            return "Please check your internet connection and try again."
        default:
            return nil
        }
    }
}
//
//  Repository.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import Foundation
import CoreData
protocol ProductRepositoryProtocol: Sendable {
    func fetchAllProducts() async throws -> [GroceryItem]
    func fetchListProducts() async throws -> [GroceryItem]
    func createProduct(id: String, productName: String, brand: String?, category: String?, price: Double, currency: String, store: String?, location: String?, imageURL: String?, barcode: String?, isInShoppingList: Bool, isOnSale: Bool) async throws -> GroceryItem
    func updateProduct(_ product: GroceryItem) async throws
    func updateProductWithPrice(product: GroceryItem, price: Double, store: String, location: String?) async throws
    func deleteProduct(_ product: GroceryItem) async throws
    func removeProductFromShoppingList(_ product: GroceryItem) async throws
    func toggleProductCompletion(_ product: GroceryItem) async throws
    func addProductToShoppingList(_ product: GroceryItem) async throws
    func fetchFavoriteProducts() async throws -> [GroceryItem]
    func addProductToFavorites(_ product: GroceryItem) async throws
    func removeProductFromFavorites(_ product: GroceryItem) async throws
    func toggleProductFavorite(_ product: GroceryItem) async throws
    func searchProducts(by name: String) async throws -> [GroceryItem]
    func searchProductsByBarcode(_ barcode: String) async throws -> [GroceryItem]
    func getLocalPriceComparison(for shoppingList: [GroceryItem]) async throws -> LocalPriceComparisonResult
    // Tag-related methods
    func fetchAllTags() async throws -> [Tag]
    func createTag(id: String, name: String, color: String) async throws -> Tag
    func updateTag(_ tag: Tag) async throws
    func addTagsToProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func replaceTagsForProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func removeTagsFromProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func initializeDefaultTags() async throws
    // ProductImage methods
    func saveProductImage(for product: GroceryItem, imageURL: String, imageData: Data?) async throws
    func getProductImage(for product: GroceryItem) async throws -> ProductImage?
    func deleteProductImage(for product: GroceryItem) async throws
}
final class ProductRepository: ProductRepositoryProtocol, @unchecked Sendable {
    private let coreDataContainer: CoreDataContainerProtocol
    init(coreDataContainer: CoreDataContainerProtocol = CoreDataContainer()) {
        self.coreDataContainer = coreDataContainer
    }
    // MARK: - Cache-First Operations
    func fetchAllProducts() async throws -> [GroceryItem] {
        // Cache-first: return all local data immediately
        return try await coreDataContainer.fetchAllProducts()
    }
    func fetchListProducts() async throws -> [GroceryItem] {
        // Cache-first: return shopping list data immediately
        return try await coreDataContainer.fetchListProducts()
    }
    func createProduct(id: String, productName: String, brand: String?, category: String?, price: Double, currency: String, store: String?, location: String?, imageURL: String?, barcode: String?, isInShoppingList: Bool = false, isOnSale: Bool = false) async throws -> GroceryItem {
        print("Repository: Creating product with store: '\(store ?? "nil")'")
        // Create locally first
        let product = try await coreDataContainer.createProduct(
            id: id,
            productName: productName,
            brand: brand,
            category: category,
            price: price,
            currency: currency,
            store: store,
            location: location,
            imageURL: imageURL,
            barcode: barcode,
            isInShoppingList: isInShoppingList,
            isOnSale: isOnSale
        )
        print("Repository: Product created, final store: '\(product.store ?? "nil")'")
        return product
    }
    func updateProduct(_ product: GroceryItem) async throws {
        // Update local cache
        try await coreDataContainer.updateProduct(product)
    }
    func updateProductWithPrice(product: GroceryItem, price: Double, store: String, location: String?) async throws {
        try await coreDataContainer.updateProductWithPrice(product: product, price: price, store: store, location: location)
    }
    func deleteProduct(_ product: GroceryItem) async throws {
        // Permanently delete from local cache
        try await coreDataContainer.deleteProduct(product)
    }
    func removeProductFromShoppingList(_ product: GroceryItem) async throws {
        // Soft delete: remove from shopping list only
        try await coreDataContainer.removeProductFromShoppingList(product)
    }
    func toggleProductCompletion(_ product: GroceryItem) async throws {
        // Toggle completion status
        try await coreDataContainer.toggleProductCompletion(product)
    }
    func addProductToShoppingList(_ product: GroceryItem) async throws {
        // Add existing product to shopping list
        try await coreDataContainer.addProductToShoppingList(product)
    }
    func fetchFavoriteProducts() async throws -> [GroceryItem] {
        // Cache-first: return favorite products immediately
        return try await coreDataContainer.fetchFavoriteProducts()
    }
    func addProductToFavorites(_ product: GroceryItem) async throws {
        // Add existing product to favorites
        try await coreDataContainer.addProductToFavorites(product)
    }
    func removeProductFromFavorites(_ product: GroceryItem) async throws {
        // Remove product from favorites
        try await coreDataContainer.removeProductFromFavorites(product)
    }
    func toggleProductFavorite(_ product: GroceryItem) async throws {
        // Toggle favorite status
        try await coreDataContainer.toggleProductFavorite(product)
    }
    func searchProducts(by name: String) async throws -> [GroceryItem] {
        // Local-only search
        return try await coreDataContainer.searchProducts(by: name)
    }
    func searchProductsByBarcode(_ barcode: String) async throws -> [GroceryItem] {
        return try await coreDataContainer.searchProductsByBarcode(barcode)
    }
    func getLocalPriceComparison(for shoppingList: [GroceryItem]) async throws -> LocalPriceComparisonResult {
        print("Repository: Starting local price comparison for \(shoppingList.count) items")
        // Get all available stores from the database
        let allStores = try await getAllStores()
        print("Repository: Found \(allStores.count) stores in database: \(allStores)")
        guard !allStores.isEmpty else {
            print("Repository: No stores found in database")
            return LocalPriceComparisonResult(
                storePrices: [],
                bestStore: nil,
                bestTotalPrice: 0.0,
                bestCurrency: "USD",
                totalItems: shoppingList.count,
                availableItems: 0
            )
        }
        var storePrices: [LocalStorePrice] = []
        // Calculate prices for each store
        for store in allStores {
            var totalPrice: Double = 0.0
            var availableItems = 0
            var unavailableItems = 0
            var itemPrices: [String: Double] = [: ]
            var itemShoppers: [String: String] = [:]
            // For each item in the shopping list, find its price at this store
            for item in shoppingList {
                guard let productName = item.productName else { continue }
                // Find the price for this item at this store
                let itemPriceResult = try await getItemPriceAndShopperAtStore(item: item, store: store)
                if let price = itemPriceResult.price, price > 0 {
                    totalPrice += price
                    availableItems += 1
                    itemPrices[productName] = price
                    if let shopper = itemPriceResult.shopper {
                        itemShoppers[productName] = shopper
                    }
                    print("Repository: Found \(productName) at \(store) for $\(price) by \(itemPriceResult.shopper ?? "Unknown")")
                } else {
                    unavailableItems += 1
                    print("Repository: \(productName) not available at \(store)")
                }
            }
            // Calculate availability percentage
            let availabilityPercentage = Double(availableItems) / Double(shoppingList.count)
            let minimumAvailability = 0.85 // 85% minimum availability threshold

            // Only include stores that have at least 85% of items available
            if availableItems > 0 && availabilityPercentage >= minimumAvailability {
                let storePrice = LocalStorePrice(
                    store: store,
                    totalPrice: totalPrice,
                    currency: "USD",
                    availableItems: availableItems,
                    unavailableItems: unavailableItems,
                    itemPrices: itemPrices,
                    itemShoppers: itemShoppers.isEmpty ? nil : itemShoppers
                )
                storePrices.append(storePrice)
                print("Repository: Store \(store) total: $\(totalPrice), available: \(availableItems)/\(shoppingList.count) (\(String(format: "%.1f", availabilityPercentage * 100))%) - INCLUDED")
            } else {
                print("Repository: Store \(store) available: \(availableItems)/\(shoppingList.count) (\(String(format: "%.1f", availabilityPercentage * 100))%) - EXCLUDED (below 85% threshold)")
            }
        }
        // Sort by total price (cheapest first) and take top 3
        let sortedStorePrices = storePrices.sorted { $0.totalPrice < $1.totalPrice }
        let top3StorePrices = Array(sortedStorePrices.prefix(3))
        // Find the best store (cheapest)
        let bestStore = top3StorePrices.first?.store
        let bestTotalPrice = top3StorePrices.first?.totalPrice ?? 0.0
        let bestCurrency = top3StorePrices.first?.currency ?? "USD"
        let comparison = LocalPriceComparisonResult(
            storePrices: top3StorePrices,
            bestStore: bestStore,
            bestTotalPrice: bestTotalPrice,
            bestCurrency: bestCurrency,
            totalItems: shoppingList.count,
            availableItems: top3StorePrices.map { $0.availableItems }.max() ?? 0
        )
        print("Repository: Local price comparison complete. Top 3 stores: \(top3StorePrices.map { "\($0.store): $\($0.totalPrice)" }.joined(separator: ", "))")
        return comparison
    }
    // Helper method to get all stores from the database
    private func getAllStores() async throws -> [String] {
        return try await coreDataContainer.getAllStores()
    }
    // Helper method to get the price of an item at a specific store
    private func getItemPriceAtStore(item: GroceryItem, store: String) async throws -> Double? {
        return try await coreDataContainer.getItemPriceAtStore(item: item, store: store)
    }

    // Helper method to get the price and shopper of an item at a specific store
    private func getItemPriceAndShopperAtStore(item: GroceryItem, store: String) async throws -> (price: Double?, shopper: String?) {
        return try await coreDataContainer.getItemPriceAndShopperAtStore(item: item, store: store)
    }
    // MARK: - Tag Methods
    func fetchAllTags() async throws -> [Tag] {
        return try await coreDataContainer.fetchAllTags()
    }
    func createTag(id: String, name: String, color: String) async throws -> Tag {
        return try await coreDataContainer.createTag(id: id, name: name, color: color)
    }
    func updateTag(_ tag: Tag) async throws {
        try await coreDataContainer.updateTag(tag)
    }
    func addTagsToProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataContainer.addTagsToProduct(product, tags: tags)
    }

    func replaceTagsForProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataContainer.replaceTagsForProduct(product, tags: tags)
    }
    func removeTagsFromProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataContainer.removeTagsFromProduct(product, tags: tags)
    }
    func initializeDefaultTags() async throws {
        try await coreDataContainer.initializeDefaultTags()
    }

    // MARK: - ProductImage Methods
    func saveProductImage(for product: GroceryItem, imageURL: String, imageData: Data?) async throws {
        try await coreDataContainer.saveProductImage(for: product, imageURL: imageURL, imageData: imageData)
    }

    func getProductImage(for product: GroceryItem) async throws -> ProductImage? {
        return try await coreDataContainer.getProductImage(for: product)
    }

    func deleteProductImage(for product: GroceryItem) async throws {
        try await coreDataContainer.deleteProductImage(for: product)
    }
}
// This code was generated with the help of Claude, saving me 7 hours of research and development.
//
//  AppColors.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/9/25.
//
import SwiftUI
struct AppColors {
    static let accentGreen = Color("AccentColorGreen")
    static let accentCoral = Color("AccentColorCoral")
    static let accentOrange = Color("AccentColorOrange")
    static let accentPink = Color("AccentColorPink")
    static let accentRed = Color("AccentColorRed")
    static let accentGray = Color("AccentColorGray")
    static let accentDarkGray = Color("AccentColorDarkGray")
    static let accentYellow = Color("AccentColorYellow")
    static let textPrimary = Color("FontColorBlack")
    static let textSecondary = Color("FontColorWhite")
    static let backgroundPrimary = Color("BackgroundColor")
    static let backgroundSecondary = Color.gray.opacity(0.05)
}
//
//  AppFonts.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/9/25.
//
import SwiftUI
extension Font {
    static func poppins(size: CGFloat, weight: Weight = .regular) -> Font {
        return Font.custom(CustomFont(weight: weight).rawValue, size: size)
    }
}
enum CustomFont: String {
    case regular = "Poppins-Regular"
    case semiBold = "Poppins-SemiBold"
    case bold = "Poppins-Bold"
    case black = "Poppins-Black"
    init(weight: Font.Weight) {
        switch weight {
        case .black, .heavy:
            self = .black
        case .bold:
            self = .bold
        case .semibold:
            self = .semiBold
        case .regular:
            self = .regular
        default:
            self = .regular
        }
    }
}
//
//  AppCoordinator.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//
import SwiftUI
class AppCoordinator: ObservableObject {
    @Published var selectedTab: TabItem = .yourList
    @Published var showSplash = true
    @AppStorage("isLoggedIn") private var isLoggedIn: Bool = false

    func selectTab(_ tab: TabItem) {
        selectedTab = tab
    }

    func logout() {
        isLoggedIn = false
    }

    func hideSplash() {
        withAnimation(.easeInOut(duration: 0.5)) {
            showSplash = false
        }
    }
}
enum TabItem: String, CaseIterable {
    case yourList = "Your List"
    case searchItems = "Search Items"
    case addItems = "Add Items"
    case socialFeed = "Social Feed"
    case myProfile = "My Profile"
    var iconName: String {
        switch self {
        case .yourList: return "list.bullet"
        case .searchItems: return "magnifyingglass"
        case .addItems: return "plus.circle"
        case .socialFeed: return "bubble.left.and.bubble.right"
        case .myProfile: return "person.circle"
        }
    }
    var selectedIconName: String {
        switch self {
        case .yourList: return "list.bullet"
        case .searchItems: return "magnifyingglass"
        case .addItems: return "plus.circle.fill"
        case .socialFeed: return "bubble.left.and.bubble.right.fill"
        case .myProfile: return "person.circle.fill"
        }
    }
}
struct AppCoordinatorView: View {
    @ObservedObject var coordinator: AppCoordinator
    @AppStorage("isLoggedIn") private var isLoggedIn: Bool = false
    @EnvironmentObject var productViewModel: ProductViewModel

    var body: some View {
        ZStack {
            // Main app content
            Group {
                if isLoggedIn {
                    TabView(selection: $coordinator.selectedTab) {
                    YourListView()
                        .tabItem {
                            Image(systemName: coordinator.selectedTab == .yourList ?
                                  TabItem.yourList.selectedIconName : TabItem.yourList.iconName)
                            Text(TabItem.yourList.rawValue)
                        }
                        .tag(TabItem.yourList)
                    SearchItemsView()
                        .tabItem {
                            Image(systemName: coordinator.selectedTab == .searchItems ?
                                  TabItem.searchItems.selectedIconName : TabItem.searchItems.iconName)
                            Text(TabItem.searchItems.rawValue)
                        }
                        .tag(TabItem.searchItems)
                        .tint(Color.accentColorBlue)
                    AddItemsView(availableTags: productViewModel.tags)
                        .tabItem {
                            Image(systemName: coordinator.selectedTab == .addItems ?
                                  TabItem.addItems.selectedIconName : TabItem.addItems.iconName)
                            Text(TabItem.addItems.rawValue)
                        }
                        .tag(TabItem.addItems)
                    SocialFeedView()
                        .tabItem {
                            Image(systemName: coordinator.selectedTab == .socialFeed ?
                                  TabItem.socialFeed.selectedIconName : TabItem.socialFeed.iconName)
                            Text(TabItem.socialFeed.rawValue)
                        }
                        .tag(TabItem.socialFeed)
                    MyProfileView()
                        .tabItem {
                            Image(systemName: coordinator.selectedTab == .myProfile ?
                                  TabItem.myProfile.selectedIconName : TabItem.myProfile.iconName)
                            Text(TabItem.myProfile.rawValue)
                        }
                        .tag(TabItem.myProfile)
                }.tint(Color.accentColorBlue)
            } else {
                LoginView()
            }
        }

        // Splash screen overlay
        if coordinator.showSplash {
            SplashScreenView()
                .transition(.opacity)
                .onAppear {
                    // Hide splash after 2.5 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                        coordinator.hideSplash()
                    }
                }
        }
        }
    }
}
// This code was generated with the help of Claude, saving me 2 hours of research and development.
//
//  DesignSystem.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import SwiftUI
struct DesignSystem {
    static let primaryColor = Color(hex: "#007AFF") // Blue, matching iOS/Figma
    static let accentColor = Color(hex: "#FF9500") // Orange, for links/buttons
    static let backgroundColor = Color(.systemGray6)
    static let bodyFont = Font.system(size: 16, weight: .regular)
    static let buttonFont = Font.system(size: 16, weight: .bold)
}
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: .whitespacesAndNewlines).replacingOccurrences(of: "#", with: "")
        var rgb: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&rgb)
        self.init(
            red: Double((rgb >> 16) & 0xFF) / 255.0,
            green: Double((rgb >> 8) & 0xFF) / 255.0,
            blue: Double(rgb & 0xFF) / 255.0
        )
    }
}
//
//  CameraViewController.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/12/25.
//
import UIKit
import AVFoundation
import SwiftUI
class CameraViewController: UIViewController {
    private var captureSession: AVCaptureSession?
    private var previewLayer: AVCaptureVideoPreviewLayer?
    private var isScanning = false
    var onBarcodeScanned: ((String) -> Void)?
    var onError: ((String) -> Void)?
    override func viewDidLoad() {
        super.viewDidLoad()
        setupCamera()
    }
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        startScanning()
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        stopScanning()
    }
    private func setupCamera() {
        // Check camera permission
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized:
            setupCaptureSession()
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
                DispatchQueue.main.async {
                    if granted {
                        self?.setupCaptureSession()
                    } else {
                        self?.onError?("Camera access is required to scan barcodes")
                    }
                }
            }
        case .denied, .restricted:
            onError?("Camera access is required to scan barcodes. Please enable it in Settings.")
        @unknown default:
            onError?("Camera access is required to scan barcodes")
        }
    }
    private func setupCaptureSession() {
        captureSession = AVCaptureSession()
        guard let captureSession = captureSession else { return }
        // Get the back camera
        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else {
            onError?("Unable to access camera")
            return
        }
        let videoInput: AVCaptureDeviceInput
        do {
            videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)
        } catch {
            onError?("Unable to initialize camera")
            return
        }
        if captureSession.canAddInput(videoInput) {
            captureSession.addInput(videoInput)
        } else {
            onError?("Unable to add camera input")
            return
        }
        let metadataOutput = AVCaptureMetadataOutput()
        if captureSession.canAddOutput(metadataOutput) {
            captureSession.addOutput(metadataOutput)
            metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)
            metadataOutput.metadataObjectTypes = [
                .ean8,
                .ean13,
                .pdf417,
                .qr,
                .code128,
                .code39,
                .upce
            ]
        } else {
            onError?("Unable to add metadata output")
            return
        }
        // Setup preview layer
        previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        previewLayer?.frame = view.layer.bounds
        previewLayer?.videoGravity = .resizeAspectFill
        if let previewLayer = previewLayer {
            view.layer.addSublayer(previewLayer)
        }
        // Add scanning overlay
        addScanningOverlay()
    }
    private func addScanningOverlay() {
        let overlayView = UIView()
        overlayView.translatesAutoresizingMaskIntoConstraints = false
        overlayView.backgroundColor = UIColor.clear
        view.addSubview(overlayView)
        NSLayoutConstraint.activate([
            overlayView.topAnchor.constraint(equalTo: view.topAnchor),
            overlayView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            overlayView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            overlayView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
        // Add scanning frame
        let scanningFrame = UIView()
        scanningFrame.translatesAutoresizingMaskIntoConstraints = false
        scanningFrame.layer.borderColor = UIColor.white.cgColor
        scanningFrame.layer.borderWidth = 2.0
        scanningFrame.backgroundColor = UIColor.clear
        overlayView.addSubview(scanningFrame)
        NSLayoutConstraint.activate([
            scanningFrame.centerXAnchor.constraint(equalTo: overlayView.centerXAnchor),
            scanningFrame.centerYAnchor.constraint(equalTo: overlayView.centerYAnchor),
            scanningFrame.widthAnchor.constraint(equalToConstant: 250),
            scanningFrame.heightAnchor.constraint(equalToConstant: 150)
        ])
        // Add corner indicators
        addCornerIndicators(to: scanningFrame)
    }
    private func addCornerIndicators(to frame: UIView) {
        let cornerLength: CGFloat = 20
        let cornerThickness: CGFloat = 3
        let corners = [
            (frame.topAnchor, frame.leadingAnchor, true, true),   // Top-left
            (frame.topAnchor, frame.trailingAnchor, true, false),  // Top-right
            (frame.bottomAnchor, frame.leadingAnchor, false, true), // Bottom-left
            (frame.bottomAnchor, frame.trailingAnchor, false, false) // Bottom-right
        ]
        for (verticalAnchor, horizontalAnchor, isTop, isLeft) in corners {
            let isBottom = !isTop
            let cornerView = UIView()
            cornerView.translatesAutoresizingMaskIntoConstraints = false
            cornerView.backgroundColor = UIColor.white
            frame.addSubview(cornerView)
            if isTop {
                cornerView.topAnchor.constraint(equalTo: verticalAnchor).isActive = true
            } else {
                cornerView.bottomAnchor.constraint(equalTo: verticalAnchor).isActive = true
            }
            if isLeft {
                cornerView.leadingAnchor.constraint(equalTo: horizontalAnchor).isActive = true
            } else {
                cornerView.trailingAnchor.constraint(equalTo: horizontalAnchor).isActive = true
            }
            if isTop || isBottom {
                cornerView.widthAnchor.constraint(equalToConstant: cornerLength).isActive = true
                cornerView.heightAnchor.constraint(equalToConstant: cornerThickness).isActive = true
            } else {
                cornerView.widthAnchor.constraint(equalToConstant: cornerThickness).isActive = true
                cornerView.heightAnchor.constraint(equalToConstant: cornerLength).isActive = true
            }
        }
    }
    private func startScanning() {
        guard let captureSession = captureSession, !captureSession.isRunning else { return }
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            captureSession.startRunning()
            DispatchQueue.main.async {
                self?.isScanning = true
            }
        }
    }
    private func stopScanning() {
        guard let captureSession = captureSession, captureSession.isRunning else { return }
        DispatchQueue.global(qos: .userInitiated).async {
            captureSession.stopRunning()
        }
        isScanning = false
    }
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        previewLayer?.frame = view.layer.bounds
    }
}
// MARK: - AVCaptureMetadataOutputObjectsDelegate
extension CameraViewController: AVCaptureMetadataOutputObjectsDelegate {
    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {
        guard isScanning else { return }
        if let metadataObject = metadataObjects.first,
           let readableObject = metadataObject as? AVMetadataMachineReadableCodeObject,
           let stringValue = readableObject.stringValue {

            // Clean the barcode value
            let cleanedBarcode = cleanBarcodeValue(stringValue)

            // Stop scanning to prevent multiple scans
            stopScanning()

            // Provide haptic feedback
            let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
            impactFeedback.impactOccurred()

            // Call the callback with cleaned barcode
            onBarcodeScanned?(cleanedBarcode)
        }
    }

    private func cleanBarcodeValue(_ barcode: String) -> String {
        // Remove leading zeros for EAN-13 barcodes (which are 13 digits)
        if barcode.count == 13 && barcode.hasPrefix("0") {
            return String(barcode.dropFirst())
        }
        return barcode
    }
}
//
//  CartWiseApp.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//
import SwiftUI
import CoreData
@main
struct CartWiseApp: App {
    @StateObject private var appCoordinator = AppCoordinator()
    @StateObject private var productViewModel = ProductViewModel(repository: ProductRepository())
    init() {
        // Tags are now seeded automatically by CoreDataStack
    }
    // Create a CoreDataStack instance for the app
    private let coreDataStack = CoreDataStack.shared
    var body: some Scene {
        WindowGroup {
            AppCoordinatorView(coordinator: appCoordinator)
                .environment(\.managedObjectContext, coreDataStack.persistentContainer.viewContext)
                .environmentObject(productViewModel)
                .preferredColorScheme(.light)
        }
    }
}
//
//  UserEntity+CoreDataClass.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import Foundation
import CoreData
@objc(UserEntity)
public class UserEntity: NSManagedObject {
}
//
//  Location+CoreDataProperties.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
extension Location {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<Location> {
        return NSFetchRequest<Location>(entityName: "Location")
    }
    @NSManaged public var id: String?
    @NSManaged public var name: String?
    @NSManaged public var address: String?
    @NSManaged public var city: String?
    @NSManaged public var state: String?
    @NSManaged public var zipCode: String?
    @NSManaged public var favorited: Bool
    @NSManaged public var isDefault: Bool
    @NSManaged public var createdAt: Date?
    @NSManaged public var updatedAt: Date?
    @NSManaged public var user: UserEntity?
    @NSManaged public var groceryItems: NSSet?
    @NSManaged public var prices: NSSet?
    @NSManaged public var experiences: NSSet?
}
extension Location {
    convenience init(context: NSManagedObjectContext, id: String, name: String, address: String, city: String, state: String, zipCode: String, favorited: Bool = false, isDefault: Bool = false) {
        self.init(context: context)
        self.id = id
        self.name = name
        self.address = address
        self.city = city
        self.state = state
        self.zipCode = zipCode
        self.favorited = favorited
        self.isDefault = isDefault
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
extension Location: Identifiable {
    // Computed property for easier access to grocery items
    var groceryItemArray: [GroceryItem] {
        let set = groceryItems as? Set<GroceryItem> ?? []
        return Array(set)
    }
    // Computed property for easier access to prices
    var priceArray: [GroceryItemPrice] {
        let set = prices as? Set<GroceryItemPrice> ?? []
        return Array(set)
    }
    // Computed property for easier access to experiences
    var experienceArray: [ShoppingExperience] {
        let set = experiences as? Set<ShoppingExperience> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
}
//
//  Tag+CoreDataClass.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/27/25.
//
import Foundation
import CoreData
@objc(Tag)
public class Tag: NSManagedObject {
    // Custom methods can be added here if needed
}
//
//  CoreDataStack.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import CoreData
import Foundation
actor CoreDataStack {
    static let shared = CoreDataStack()
    private init() {}
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "ProductModel")
        // Configure migration options
        let description = container.persistentStoreDescriptions.first
        description?.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
        description?.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
        // Load persistent stores
        container.loadPersistentStores { _, error in
            if let error = error {
                print("Core Data failed to load: \(error.localizedDescription)")
                // Instead of fatal error, try to delete and recreate
                self.handleCoreDataError(error)
            }
        }
        container.viewContext.automaticallyMergesChangesFromParent = true
        // Seed tags after container is loaded
        Task {
            try? await seedTagsIfNeeded()
        }
        return container
    }()
    var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    func save() async throws {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            try await context.perform {
                try context.save()
            }
        }
    }
    func performBackgroundTask<T>(_ block: @escaping (NSManagedObjectContext) throws -> T) async throws -> T {
        return try await withCheckedThrowingContinuation { continuation in
            persistentContainer.performBackgroundTask { context in
                do {
                    let result = try block(context)
                    continuation.resume(returning: result)
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }
    private func seedTagsIfNeeded() async throws {
        try await performBackgroundTask { context in
            try TagSeedData.seedTags(in: context)
        }
    }
    func ensureTagsSeeded() async throws {
        try await seedTagsIfNeeded()
    }
    private func handleCoreDataError(_ error: Error) {
        print("Core Data error: \(error.localizedDescription)")
        print("Attempting to delete and recreate persistent store...")
        // Delete the existing store
        guard let storeURL = persistentContainer.persistentStoreDescriptions.first?.url else {
            fatalError("Could not get store URL")
        }
        do {
            // Remove the store from the container first
            if let store = persistentContainer.persistentStoreCoordinator.persistentStores.first {
                try persistentContainer.persistentStoreCoordinator.remove(store)
            }
            // Delete the file
            try FileManager.default.removeItem(at: storeURL)
            print("Successfully deleted old store")
            // Try to load again
            persistentContainer.loadPersistentStores { _, error in
                if let error = error {
                    print("Failed to load after deletion: \(error.localizedDescription)")
                    fatalError("Core Data failed to load after store deletion: \(error.localizedDescription)")
                } else {
                    print("Successfully loaded new store")
                }
            }
        } catch {
            print("Failed to delete store: \(error.localizedDescription)")
            fatalError("Could not delete and recreate Core Data store: \(error.localizedDescription)")
        }
    }
}
//
//  GroceryItemPrice+CoreDataProperties.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
extension GroceryItemPrice {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<GroceryItemPrice> {
        return NSFetchRequest<GroceryItemPrice>(entityName: "GroceryItemPrice")
    }
    @NSManaged public var id: String?
    @NSManaged public var price: Double
    @NSManaged public var currency: String?
    @NSManaged public var store: String?
    @NSManaged public var lastUpdated: Date?
    @NSManaged public var createdAt: Date?
    @NSManaged public var updatedBy: String?
    @NSManaged public var groceryItem: GroceryItem?
    @NSManaged public var location: Location?
}
extension GroceryItemPrice {
    convenience init(context: NSManagedObjectContext, id: String, price: Double, currency: String = "USD", store: String? = nil, groceryItem: GroceryItem, location: Location, updatedBy: String? = nil) {
        self.init(context: context)
        self.id = id
        self.price = price
        self.currency = currency
        self.store = store
        self.groceryItem = groceryItem
        self.location = location
        self.updatedBy = updatedBy
        self.createdAt = Date()
        self.lastUpdated = Date()
    }
}
extension GroceryItemPrice: Identifiable {
}
//
//  UserComment+CoreDataProperties.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
extension UserComment {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<UserComment> {
        return NSFetchRequest<UserComment>(entityName: "UserComment")
    }
    @NSManaged public var id: String?
    @NSManaged public var comment: String?
    @NSManaged public var rating: Int16
    @NSManaged public var createdAt: Date?
    @NSManaged public var user: UserEntity?
    @NSManaged public var experience: ShoppingExperience?
}
extension UserComment {
    convenience init(context: NSManagedObjectContext, id: String, comment: String, rating: Int16 = 0, user: UserEntity? = nil, experience: ShoppingExperience? = nil) {
        self.init(context: context)
        self.id = id
        self.comment = comment
        self.rating = rating
        self.user = user
        self.experience = experience
        self.createdAt = Date()
    }
}
extension UserComment: Identifiable {
}
//
//  UserComment+CoreDataClass.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
@objc(UserComment)
public class UserComment: NSManagedObject {
}
//
//  ShoppingExperience+CoreDataClass.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
@objc(ShoppingExperience)
public class ShoppingExperience: NSManagedObject {
}
//
//  ReputationSystem.swift
//  CartWise
//
//  Created by CartWise Development Team on 12/19/24.
//

import SwiftUI

struct ShopperLevel {
    let name: String
    let icon: String
    let color: Color
    let minUpdates: Int
    let description: String
}

class ReputationSystem: ObservableObject {
    static let shared = ReputationSystem()

    let levels: [ShopperLevel] = [
        ShopperLevel(
            name: "New Shopper",
            icon: "cart.badge.plus",
            color: .gray,
            minUpdates: 0,
            description: "Just getting started with product contributions"
        ),
        ShopperLevel(
            name: "Regular Shopper",
            icon: "cart.fill",
            color: .green,
            minUpdates: 10,
            description: "Consistently helping the community"
        ),
        ShopperLevel(
            name: "Smart Shopper",
            icon: "cart.circle.fill",
            color: .blue,
            minUpdates: 25,
            description: "A trusted source for product information"
        ),
        ShopperLevel(
            name: "Expert Shopper",
            icon: "cart.badge.checkmark",
            color: .orange,
            minUpdates: 50,
            description: "Highly reliable product contributions"
        ),
        ShopperLevel(
            name: "Master Shopper",
            icon: "crown.fill",
            color: .yellow,
            minUpdates: 100,
            description: "The ultimate product contribution authority"
        ),
        ShopperLevel(
            name: "Legendary Shopper",
            icon: "star.circle.fill",
            color: .pink,
            minUpdates: 200,
            description: "A legend in the shopping community"
        )
    ]

    func getCurrentLevel(updates: Int) -> ShopperLevel {
        for level in levels.reversed() {
            if updates >= level.minUpdates {
                return level
            }
        }
        return levels.first!
    }

    func getNextLevel(updates: Int) -> ShopperLevel? {
        let currentLevel = getCurrentLevel(updates: updates)
        guard let currentIndex = levels.firstIndex(where: { $0.name == currentLevel.name }) else {
            return nil
        }

        let nextIndex = currentIndex + 1
        return nextIndex < levels.count ? levels[nextIndex] : nil
    }

    func getProgressToNextLevel(updates: Int) -> Double {
        let currentLevel = getCurrentLevel(updates: updates)
        guard let nextLevel = getNextLevel(updates: updates) else {
            return 1.0 // Max level reached
        }

        let updatesInCurrentLevel = updates - currentLevel.minUpdates
        let updatesNeededForNextLevel = nextLevel.minUpdates - currentLevel.minUpdates

        return Double(updatesInCurrentLevel) / Double(updatesNeededForNextLevel)
    }

    func getUpdatesToNextLevel(updates: Int) -> Int {
        guard let nextLevel = getNextLevel(updates: updates) else {
            return 0 // Max level reached
        }

        return nextLevel.minUpdates - updates
    }
}
//
//  Location+CoreDataClass.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
@objc(Location)
public class Location: NSManagedObject {
}
//
//  Tag+CoreDataProperties.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/27/25.
//
import Foundation
import CoreData
extension Tag {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<Tag> {
        return NSFetchRequest<Tag>(entityName: "Tag")
    }
    @NSManaged public var id: String?
    @NSManaged public var name: String?
    @NSManaged public var color: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var updatedAt: Date?
    @NSManaged public var products: NSSet?
}
extension Tag {
    convenience init(context: NSManagedObjectContext, id: String, name: String, color: String = "#007AFF") {
        self.init(context: context)
        self.id = id
        self.name = name
        self.color = color
        self.createdAt = Date()
        self.updatedAt = Date()
    }
}
extension Tag: Identifiable {
    // Computed properties for easier access
    var displayName: String {
        return name ?? "Unnamed Tag"
    }
    var displayColor: String {
        return color ?? "#007AFF"
    }
    var productArray: [GroceryItem] {
        let set = products as? Set<GroceryItem> ?? []
        return Array(set)
    }
}
//
//  TagSeedData.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/27/25.
//
import Foundation
import CoreData
struct TagSeedData {
    static let seededTags: [(name: String, color: String)] = [
        // Original 20 tags
        ("Toilet Paper", "#FF6B6B"),
        ("All-Purpose Cleaner", "#4ECDC4"),
        ("Hand Sanitizer", "#45B7D1"),
        ("Paper Towels", "#96CEB4"),
        ("Dish Soap", "#FFEAA7"),
        ("Laundry Detergent", "#DDA0DD"),
        ("Trash Bags", "#98D8C8"),
        ("Batteries", "#F7DC6F"),
        ("Light Bulbs", "#BB8FCE"),
        ("First Aid", "#E74C3C"),
        ("Vitamins", "#F39C12"),
        ("Pet Food", "#8E44AD"),
        ("Baby Items", "#E91E63"),
        ("Office Supplies", "#607D8B"),
        ("Kitchen Essentials", "#795548"),
        ("Bathroom Items", "#9C27B0"),
        ("Cleaning Supplies", "#00BCD4"),
        ("Personal Care", "#FF9800"),
        ("Snacks", "#4CAF50"),
        ("Beverages", "#2196F3"),
        // Energy Drinks (as requested)
        ("Energy Drink", "#FF5722"),
        ("Red Bull", "#D32F2F"),
        ("Monster", "#FF9800"),
        ("Rockstar", "#FFC107"),
        ("Bang", "#9C27B0"),
        ("5-Hour Energy", "#FFEB3B"),
        ("NOS", "#F44336"),
        ("Amp", "#E91E63"),
        ("Full Throttle", "#FF5722"),
        ("Xyience", "#9C27B0"),
        // Store Brands (as requested)
        ("Store Brand", "#607D8B"),
        ("Great Value", "#4CAF50"),
        ("Kirkland", "#2196F3"),
        ("Up&Up", "#FF9800"),
        ("Equate", "#9C27B0"),
        ("Member's Mark", "#795548"),
        ("365 Everyday Value", "#4CAF50"),
        ("Good & Gather", "#2196F3"),
        ("Market Pantry", "#FF9800"),
        ("Simply Nature", "#8BC34A"),
        // Organic (as requested)
        ("Organic", "#4CAF50"),
        ("USDA Organic", "#2E7D32"),
        ("Certified Organic", "#388E3C"),
        ("Organic Produce", "#66BB6A"),
        ("Organic Dairy", "#81C784"),
        ("Organic Meat", "#A5D6A7"),
        ("Organic Grains", "#C8E6C9"),
        ("Organic Snacks", "#E8F5E8"),
        ("Organic Beverages", "#4CAF50"),
        ("Organic Personal Care", "#66BB6A"),
        // Food Categories
        ("Fruits", "#FF9800"),
        ("Vegetables", "#4CAF50"),
        ("Meat", "#D32F2F"),
        ("Dairy", "#2196F3"),
        ("Bread", "#8D6E63"),
        ("Cereal", "#FFC107"),
        ("Pasta", "#FF9800"),
        ("Rice", "#8D6E63"),
        ("Beans", "#795548"),
        ("Nuts", "#8D6E63"),
        ("Seeds", "#8D6E63"),
        ("Oils", "#FFC107"),
        ("Condiments", "#FF5722"),
        ("Spices", "#795548"),
        ("Herbs", "#4CAF50"),
        ("Sauces", "#FF5722"),
        ("Dressings", "#FF9800"),
        ("Jams & Jellies", "#E91E63"),
        ("Peanut Butter", "#8D6E63"),
        // Beverage Categories
        ("Coffee", "#8D6E63"),
        ("Tea", "#4CAF50"),
        ("Juice", "#FF9800"),
        ("Soda", "#F44336"),
        ("Water", "#2196F3"),
        ("Sports Drinks", "#00BCD4"),
        ("Milk", "#E3F2FD"),
        ("Plant Milk", "#8BC34A"),
        ("Alcoholic Beverages", "#9C27B0"),
        ("Sparkling Water", "#00BCD4"),
        // Health & Wellness
        ("Gluten Free", "#4CAF50"),
        ("Dairy Free", "#2196F3"),
        ("Vegan", "#4CAF50"),
        ("Vegetarian", "#8BC34A"),
        ("Keto", "#9C27B0"),
        ("Paleo", "#795548"),
        ("Low Carb", "#607D8B"),
        ("Sugar Free", "#E91E63"),
        ("Low Sodium", "#00BCD4"),
        ("High Protein", "#FF5722"),
        // Household Categories
        ("Kitchen", "#FF9800"),
        ("Bathroom", "#2196F3"),
        ("Laundry", "#9C27B0"),
        ("Storage", "#607D8B"),
        ("Tools", "#795548"),
        ("Electronics", "#9E9E9E"),
        ("Garden", "#4CAF50"),
        ("Automotive", "#FF5722"),
        ("Hardware", "#795548"),
        ("Seasonal", "#FF9800"),
        // Special Categories
        ("On Sale", "#E91E63"),
        ("New Product", "#4CAF50"),
        ("Limited Edition", "#9C27B0"),
        ("Seasonal Item", "#FF9800"),
        ("Holiday", "#E91E63"),
        ("Gift", "#9C27B0"),
        ("Bulk", "#795548"),
        ("Single Serve", "#2196F3"),
        ("Family Size", "#FF9800"),
        ("Travel Size", "#607D8B"),
        // Dietary Restrictions
        ("Nut Free", "#4CAF50"),
        ("Soy Free", "#8BC34A"),
        ("Egg Free", "#FFC107"),
        ("Fish Free", "#00BCD4"),
        ("Shellfish Free", "#FF9800"),
        ("Wheat Free", "#8D6E63"),
        ("Corn Free", "#FFC107"),
        ("MSG Free", "#4CAF50"),
        ("Artificial Colors", "#E91E63"),
        ("Preservative Free", "#4CAF50")
    ]
    static func seedTags(in context: NSManagedObjectContext) throws {
        // Check if tags already exist
        let request: NSFetchRequest<Tag> = Tag.fetchRequest()
        let existingTags = try context.fetch(request)
        // If we have the full set of tags (100), don't recreate
        if existingTags.count >= seededTags.count {
            return // Tags already seeded
        }
        // If we have some tags but not all, add the missing ones
        let existingTagNames = Set(existingTags.compactMap { $0.name })
        let newTagsToCreate = seededTags.filter { !existingTagNames.contains($0.name) }
        // Create missing tags
        for (name, color) in newTagsToCreate {
            let tag = Tag(context: context, id: UUID().uuidString, name: name, color: color)
        }
        try context.save()
    }
}
//
//  GroceryItem+CoreDataProperties.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import Foundation
import CoreData
import UIKit
extension GroceryItem {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<GroceryItem> {
        return NSFetchRequest<GroceryItem>(entityName: "GroceryItem")
    }
    @NSManaged public var id: String?
    @NSManaged public var productName: String?
    @NSManaged public var brand: String?
    @NSManaged public var category: String?
    @NSManaged public var lastUpdated: Date?
    @NSManaged public var barcode: String?
    @NSManaged public var productImage: ProductImage?
    @NSManaged public var isCompleted: Bool
    @NSManaged public var isInShoppingList: Bool
    @NSManaged public var isFavorite: Bool
    @NSManaged public var isOnSale: Bool
    @NSManaged public var createdAt: Date?
    @NSManaged public var updatedAt: Date?
    @NSManaged public var tags: NSSet?
    @NSManaged public var locations: NSSet?
    @NSManaged public var prices: NSSet?
    @NSManaged public var experiences: NSSet?
}
extension GroceryItem {
    convenience init(context: NSManagedObjectContext, id: String, productName: String, brand: String? = nil, category: String? = nil, barcode: String? = nil, isOnSale: Bool = false) {
        self.init(context: context)
        self.id = id
        self.productName = productName
        self.brand = brand
        self.category = category
        self.barcode = barcode
        self.isCompleted = false
        self.isInShoppingList = false
        self.isFavorite = false
        self.isOnSale = isOnSale
        self.createdAt = Date()
        self.updatedAt = Date()
        self.lastUpdated = Date()
    }
}
extension GroceryItem: Identifiable {
    // Computed property for easier access to tags
    var tagArray: [Tag] {
        let set = tags as? Set<Tag> ?? []
        return Array(set)
    }
    // Computed property for easier access to locations
    var locationArray: [Location] {
        let set = locations as? Set<Location> ?? []
        return Array(set)
    }
    // Computed property for easier access to prices
    var priceArray: [GroceryItemPrice] {
        let set = prices as? Set<GroceryItemPrice> ?? []
        return Array(set)
    }
    // Computed property for easier access to experiences
    var experienceArray: [ShoppingExperience] {
        let set = experiences as? Set<ShoppingExperience> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
    // Helper method to get the current price at a specific location
    func getPrice(at location: Location) -> GroceryItemPrice? {
        return priceArray.first { $0.location == location }
    }
    // Helper method to get all prices across all locations
    func getAllPrices() -> [GroceryItemPrice] {
        return priceArray
    }
    // Helper method to get the lowest valid price (ignores orphaned or invalid entries)
    func getLowestPrice() -> GroceryItemPrice? {
        // Only consider prices that have a valid, non-deleted location and a positive price
        let validPrices = priceArray.filter { price in
            guard price.price > 0 else { return false }
            guard let location = price.location else { return false }
            return !location.isDeleted
        }
        // Choose the minimum by price; tie-breaker by most recent update
        return validPrices.min { lhs, rhs in
            if lhs.price == rhs.price {
                let lUpdated = lhs.lastUpdated ?? .distantPast
                let rUpdated = rhs.lastUpdated ?? .distantPast
                return lUpdated > rUpdated
            }
            return lhs.price < rhs.price
        }
    }
    // Helper method to get the highest price
    func getHighestPrice() -> GroceryItemPrice? {
        return priceArray.max { $0.price < $1.price }
    }
    // Backward compatibility properties
    var price: Double {
        return getLowestPrice()?.price ?? 0.0
    }
    var store: String? {
        return getLowestPrice()?.store
    }
    var location: String? {
        return getLowestPrice()?.location?.name
    }
    var currency: String? {
        return getLowestPrice()?.currency
    }

    // Image compatibility properties
    var imageURL: String? {
        return productImage?.imageURL
    }

    var imageData: Data? {
        return productImage?.imageData
    }

    var uiImage: UIImage? {
        return productImage?.uiImage
    }
}
//
//  ShoppingExperience+CoreDataProperties.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
extension ShoppingExperience {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<ShoppingExperience> {
        return NSFetchRequest<ShoppingExperience>(entityName: "ShoppingExperience")
    }
    @NSManaged public var id: String?
    @NSManaged public var comment: String?
    @NSManaged public var rating: Int16
    @NSManaged public var type: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var user: UserEntity?
    @NSManaged public var groceryItem: GroceryItem?
    @NSManaged public var location: Location?
    @NSManaged public var comments: NSSet?
}
extension ShoppingExperience {
    convenience init(context: NSManagedObjectContext, id: String, comment: String, rating: Int16 = 0, type: String? = nil, user: UserEntity? = nil, groceryItem: GroceryItem? = nil, location: Location? = nil) {
        self.init(context: context)
        self.id = id
        self.comment = comment
        self.rating = rating
        self.type = type
        self.user = user
        self.groceryItem = groceryItem
        self.location = location
        self.createdAt = Date()
    }
}
extension ShoppingExperience: Identifiable {
    // Computed property for easier access to comments
    var commentArray: [UserComment] {
        let set = comments as? Set<UserComment> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
    // Computed property for display name
    var displayName: String {
        if let groceryItem = groceryItem {
            return groceryItem.productName ?? "Unknown Product"
        } else if let location = location {
            return location.name ?? "Unknown Location"
        }
        return "Shopping Experience"
    }
    // Computed property for display type
    var displayType: String {
        switch type {
        case "price_update":
            return "Price Update"
        case "store_review":
            return "Store Review"
        case "product_review":
            return "Product Review"
        case "new_product":
            return "New Product"
        case "general":
            return "General Comment"
        case "new_product":
            return "New Product"
        default:
            return "Shopping Experience"
        }
    }
}
//
//  User.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import Foundation
struct User: Identifiable, Codable {
    let id: String
    let username: String
    let updates: Int
    var level: String {
        updates > 50 ? "Master Shopper" : updates > 10 ? "Shopper" : "Newbie"
    }
}
//
//  Product.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import Foundation
import CoreData
// Product categories enum
enum ProductCategory: String, CaseIterable {
    case none = "Select Category"
    case meat = "Meat & Seafood"
    case dairy = "Dairy & Eggs"
    case bakery = "Bakery"
    case produce = "Produce"
    case pantry = "Pantry Items"
    case beverages = "Beverages"
    case frozen = "Frozen Foods"
    case household = "Household & Personal Care"
}
// MARK: - Main Response Model
struct APIResponse: Codable {
    let success: Bool
    let pagination: Pagination?
    let products: [APIProduct]
}
// MARK: - Pagination Model
struct Pagination: Codable {
    let currentPage: Int
    let nextPage: Int?
    let totalPages: Int  // Note: This comes as string, not int
}
// MARK: - Product Model
struct APIProduct: Codable {
    let name: String
    let price: String
    let currency: String
    let customerReview: String  // Can be empty string
    let customerReviewCount: String
    let shippingMessage: String  // Can be empty string
    let amazonLink: String
    let image: String
    let boughtInfo: String  // Can be empty string
}
struct Product: Identifiable, Codable {
    let id: String
    let name: String
    let brand: String?
    let category: String?
    let price: Double
    let currency: String
    let store: String?
    let location: String?
    let imageURL: String?
    let barcode: String?
    let isOnSale: Bool
}
// Local price comparison model
struct LocalPriceComparison: Codable, Sendable {
    let productName: String
    let localPrices: [Double]
    var averagePrice: Double {
        guard !localPrices.isEmpty else { return 0.0 }
        return localPrices.reduce(0, +) / Double(localPrices.count)
    }
    var minPrice: Double {
        localPrices.min() ?? 0.0
    }
    var maxPrice: Double {
        localPrices.max() ?? 0.0
    }
}
// Local store price model
struct LocalStorePrice: Codable, Sendable {
    let store: String
    let totalPrice: Double
    let currency: String
    let availableItems: Int
    let unavailableItems: Int
    let itemPrices: [String: Double] // productName -> price
    let itemShoppers: [String: String]? // productName -> shopper username
}
// Local price comparison result
struct LocalPriceComparisonResult: Codable, Sendable {
    let storePrices: [LocalStorePrice]
    let bestStore: String?
    let bestTotalPrice: Double
    let bestCurrency: String
    let totalItems: Int
    let availableItems: Int
}
// Price comparison models for UI
struct StorePrice: Codable, Sendable {
    let store: String
    let totalPrice: Double
    let currency: String
    let availableItems: Int
    let unavailableItems: Int
    let itemPrices: [String: Double] // productName -> price
    let itemShoppers: [String: String]? // productName -> shopper username
}
struct PriceComparison: Codable, Sendable {
    let storePrices: [StorePrice]
    let bestStore: String?
    let bestTotalPrice: Double
    let bestCurrency: String
    let totalItems: Int
    let availableItems: Int
}
//
//  ProductImage.swift
//  CartWise
//
//  Created by Kelly Yong on 8/4/25.
//  Enhanced with AI assistance from Cursor AI.
//

import Foundation
import CoreData
import UIKit

@objc(ProductImage)
public class ProductImage: NSManagedObject {

}

extension ProductImage {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<ProductImage> {
        return NSFetchRequest<ProductImage>(entityName: "ProductImage")
    }

    @NSManaged public var id: String?
    @NSManaged public var imageData: Data?
    @NSManaged public var imageURL: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var updatedAt: Date?
    @NSManaged public var groceryItem: GroceryItem?

    convenience init(context: NSManagedObjectContext, id: String, imageURL: String?, imageData: Data? = nil) {
        self.init(context: context)
        self.id = id
        self.imageURL = imageURL
        self.imageData = imageData
        self.createdAt = Date()
        self.updatedAt = Date()
    }

    // Helper method to get UIImage from imageData
    var uiImage: UIImage? {
        guard let imageData = imageData else { return nil }
        return UIImage(data: imageData)
    }

    // Helper method to set UIImage to imageData
    func setImage(_ image: UIImage) {
        self.imageData = image.jpegData(compressionQuality: 0.8)
        self.updatedAt = Date()
    }
}
//
//  UserEntity+CoreDataProperties.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import Foundation
import CoreData
extension UserEntity {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<UserEntity> {
        return NSFetchRequest<UserEntity>(entityName: "UserEntity")
    }
    @NSManaged public var id: String?
    @NSManaged public var username: String?
    @NSManaged public var password: String?
    @NSManaged public var updates: Int32
    @NSManaged public var level: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var locations: NSSet?
    @NSManaged public var experiences: NSSet?
    @NSManaged public var comments: NSSet?
}
extension UserEntity: Identifiable {
    // Computed property for easier access to locations
    var locationArray: [Location] {
        let set = locations as? Set<Location> ?? []
        return Array(set)
    }
    // Computed property for easier access to experiences
    var experienceArray: [ShoppingExperience] {
        let set = experiences as? Set<ShoppingExperience> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
    // Computed property for easier access to comments
    var commentArray: [UserComment] {
        let set = comments as? Set<UserComment> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
}
//
//  ReputationManager.swift
//  CartWise
//
//  Created by CartWise Development Team on 12/19/24.
//

import Foundation
import CoreData

class ReputationManager: ObservableObject {
    static let shared = ReputationManager()

    private init() {}

    func updateUserReputation(userId: String) async {
        // Use CoreDataStack to ensure we're in the right context
        let context = await CoreDataStack.shared.viewContext

        do {
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "id == %@", userId)

            let users = try context.fetch(fetchRequest)

            if let user = users.first {
                // Increment updates count
                user.updates += 1

                // Update level based on new count
                let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(user.updates))
                user.level = newLevel.name

                // Save to Core Data
                try context.save()

                print("Updated reputation for user \(userId): \(user.updates) updates, level: \(newLevel.name)")
            } else {
                // Try to find user by username if ID not found
                let usernameFetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
                usernameFetchRequest.predicate = NSPredicate(format: "username == %@", userId)

                let usersByUsername = try context.fetch(usernameFetchRequest)

                if let user = usersByUsername.first {
                    // Increment updates count
                    user.updates += 1

                    // Update level based on new count
                    let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(user.updates))
                    user.level = newLevel.name

                    // Save to Core Data
                    try context.save()

                    print("Updated reputation for user \(userId): \(user.updates) updates, level: \(newLevel.name)")
                }
            }
        } catch {
            print("Error updating user reputation: \(error)")
        }
    }

    func getUserReputation(userId: String) async -> (updates: Int, level: String)? {
        let context = await CoreDataStack.shared.viewContext

        do {
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "id == %@", userId)

            let users = try context.fetch(fetchRequest)

            if let user = users.first {
                return (Int(user.updates), user.level ?? "New Shopper")
            }
        } catch {
            print("Error fetching user reputation: \(error)")
        }

        return nil
    }

    func getCurrentUserReputation() async -> (updates: Int, level: String)? {
        let context = await CoreDataStack.shared.viewContext

        do {
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1

            let users = try context.fetch(fetchRequest)

            if let user = users.first {
                print("ReputationManager: Found user \(user.username ?? "Unknown") with \(user.updates) updates, level: \(user.level ?? "None")")
                return (Int(user.updates), user.level ?? "New Shopper")
            } else {
                print("ReputationManager: No users found")
            }
        } catch {
            print("Error fetching current user reputation: \(error)")
        }

        return nil
    }

    // Debug function to manually test reputation updates
    func debugReputationUpdate() async {
        let context = await CoreDataStack.shared.viewContext

        do {
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1

            let users = try context.fetch(fetchRequest)

            if let user = users.first {
                print("Debug: Current user \(user.username ?? "Unknown") has \(user.updates) updates")

                // Manually increment updates
                user.updates += 1
                let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(user.updates))
                user.level = newLevel.name

                try context.save()

                print("Debug: Updated user to \(user.updates) updates, level: \(newLevel.name)")
            } else {
                print("Debug: No users found")
            }
        } catch {
            print("Debug: Error updating reputation: \(error)")
        }
    }
}
//
//  CoreDataContainer.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import Foundation
import CoreData
import SwiftUI
protocol CoreDataContainerProtocol: Sendable {
    func fetchAllProducts() async throws -> [GroceryItem]
    func fetchListProducts() async throws -> [GroceryItem]
    // func fetchRecentProducts(limit: Int) async throws -> [GroceryItem]
    func createProduct(id: String, productName: String, brand: String?, category: String?, price: Double, currency: String, store: String?, location: String?, imageURL: String?, barcode: String?, isInShoppingList: Bool, isOnSale: Bool) async throws -> GroceryItem
    func updateProduct(_ product: GroceryItem) async throws
    func updateProductWithPrice(product: GroceryItem, price: Double, store: String, location: String?) async throws
    func deleteProduct(_ product: GroceryItem) async throws
    func toggleProductCompletion(_ product: GroceryItem) async throws
    func addProductToShoppingList(_ product: GroceryItem) async throws
    func fetchFavoriteProducts() async throws -> [GroceryItem]
    func addProductToFavorites(_ product: GroceryItem) async throws
    func removeProductFromFavorites(_ product: GroceryItem) async throws
    func toggleProductFavorite(_ product: GroceryItem) async throws
    func searchProducts(by name: String) async throws -> [GroceryItem]
    func searchProductsByBarcode(_ barcode: String) async throws -> [GroceryItem]
    func searchProductsByTag(_ tag: Tag) async throws -> [GroceryItem]
    func removeProductFromShoppingList(_ product: GroceryItem) async throws
    // Price comparison methods
    func getAllStores() async throws -> [String]
    func getItemPriceAtStore(item: GroceryItem, store: String) async throws -> Double?
    func getItemPriceAndShopperAtStore(item: GroceryItem, store: String) async throws -> (price: Double?, shopper: String?)
    // Tag-related methods
    func fetchAllTags() async throws -> [Tag]
    func createTag(id: String, name: String, color: String) async throws -> Tag
    func updateTag(_ tag: Tag) async throws
    func addTagsToProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func replaceTagsForProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func removeTagsFromProduct(_ product: GroceryItem, tags: [Tag]) async throws
    func initializeDefaultTags() async throws
    // ProductImage methods
    func saveProductImage(for product: GroceryItem, imageURL: String, imageData: Data?) async throws
    func getProductImage(for product: GroceryItem) async throws -> ProductImage?
    func deleteProductImage(for product: GroceryItem) async throws
}
final class CoreDataContainer: CoreDataContainerProtocol, @unchecked Sendable {
    private let coreDataStack: CoreDataStack
    init(coreDataStack: CoreDataStack = CoreDataStack.shared) {
        self.coreDataStack = coreDataStack
    }
    func fetchAllProducts() async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.createdAt, ascending: false)]
            return try context.fetch(request)
        }
    }
    func fetchListProducts() async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.predicate = NSPredicate(format: "isInShoppingList == YES")
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.createdAt, ascending: false)]
            let products = try context.fetch(request)
            print("CoreDataContainer: Fetched \(products.count) shopping list products")
            for (index, product) in products.enumerated() {
                print("CoreDataContainer: Product \(index + 1): '\(product.productName ?? "Unknown")' - Store: '\(product.store ?? "nil")' - Price: $\(product.price)")
            }
            return products
        }
    }
    // func fetchRecentProducts(limit: Int) async throws -> [GroceryItem] {
    //     // Use viewContext through the actor
    //     let context = await coreDataStack.viewContext
    //     return try await context.perform {
    //         let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
    //     // Get all products (not just shopping list) sorted by creation date
    //         request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.createdAt, ascending: false)]
    //         request.fetchLimit = limit
    //         return try context.fetch(request)
    //     }
    // }
    // createProduct was creating GroceryItem objects in background Core Data context, but ViewModel expecting objects from main context.
    func createProduct(id: String, productName: String, brand: String?, category: String?, price: Double, currency: String, store: String?, location: String?, imageURL: String?, barcode: String?, isInShoppingList: Bool = false, isOnSale: Bool = false) async throws -> GroceryItem {
        print("CoreDataContainer: Creating product with store: '\(store ?? "nil")'")
        let currentUsername = await getCurrentUsername()
        // Create in background context first
        let objectID = try await coreDataStack.performBackgroundTask { context in
            let product = GroceryItem(
                context: context,
                id: id,
                productName: productName,
                brand: brand,
                category: category,
                barcode: barcode,
                isOnSale: isOnSale
            )
            print("CoreDataContainer: Product created, store set to: '\(product.store ?? "nil")'")
            // Set shopping list status based on parameter
            product.isInShoppingList = isInShoppingList

            // Create ProductImage if imageURL is provided
            if let imageURL = imageURL {
                let productImage = ProductImage(
                    context: context,
                    id: UUID().uuidString,
                    imageURL: imageURL
                )
                product.productImage = productImage
            }

            // If we have price and store information, create a GroceryItemPrice
            if price > 0, let store = store {
                // Find or create the location
                let locationEntity = try self.findOrCreateLocation(context: context, name: store, address: location)
                // Create the price entity
                let priceEntity = GroceryItemPrice(
                    context: context,
                    id: UUID().uuidString,
                    price: price,
                    currency: currency,
                    store: store,
                    groceryItem: product,
                    location: locationEntity,
                    updatedBy: currentUsername
                )
            }
            try context.save()
            print("CoreDataContainer: Context saved, final store: '\(product.store ?? "nil")'")

            // Update user reputation for product creation (barcode scanning)
            if let currentUser = try context.fetch(NSFetchRequest<UserEntity>(entityName: "UserEntity")).first(where: { $0.username == currentUsername }) {
                // Increment updates count
                currentUser.updates += 1

                // Update level based on new count
                let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(currentUser.updates))
                currentUser.level = newLevel.name

                // Save the context to persist the reputation update
                try context.save()

                print("✅ REPUTATION UPDATE: Product creation - user \(currentUsername): \(currentUser.updates) updates, level: \(newLevel.name)")
            } else {
                print("⚠️ WARNING: Could not find current user for product creation reputation update")
            }

            return product.objectID
        }
        // Then fetch from main context to ensure proper access
        let viewContext = await coreDataStack.viewContext
        return try await viewContext.perform {
            let fetchedProduct = try viewContext.existingObject(with: objectID) as! GroceryItem
            print("CoreDataContainer: Fetched product from main context, store: '\(fetchedProduct.store ?? "nil")'")
            return fetchedProduct
        }
    }
    // Helper method to find or create a location
    private func findOrCreateLocation(context: NSManagedObjectContext, name: String, address: String?) throws -> Location {
        let request: NSFetchRequest<Location> = Location.fetchRequest()
        request.predicate = NSPredicate(format: "name == %@", name)
        request.fetchLimit = 1
        let existingLocations = try context.fetch(request)
        if let existingLocation = existingLocations.first {
            return existingLocation
        }
        // Create new location
        let newLocation = Location(context: context)
        newLocation.id = UUID().uuidString
        newLocation.name = name
        newLocation.address = address
        newLocation.createdAt = Date()
        newLocation.updatedAt = Date()
        return newLocation
    }

    // ProductImage Methods
    func saveProductImage(for product: GroceryItem, imageURL: String, imageData: Data? = nil) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem

            // Create or update ProductImage
            let productImage: ProductImage
            if let existingImage = productInContext.productImage {
                // Update existing image
                let imageObjectID = existingImage.objectID
                productImage = try context.existingObject(with: imageObjectID) as! ProductImage
                productImage.imageURL = imageURL
                if let imageData = imageData {
                    productImage.imageData = imageData
                }
                productImage.updatedAt = Date()
            } else {
                // Create new image
                productImage = ProductImage(
                    context: context,
                    id: UUID().uuidString,
                    imageURL: imageURL,
                    imageData: imageData
                )
                productInContext.productImage = productImage
            }

            try context.save()
        }
    }

    func getProductImage(for product: GroceryItem) async throws -> ProductImage? {
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            return productInContext.productImage
        }
    }

    func deleteProductImage(for product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem

            if let productImage = productInContext.productImage {
                let imageObjectID = productImage.objectID
                let imageInContext = try context.existingObject(with: imageObjectID) as! ProductImage
                context.delete(imageInContext)
                productInContext.productImage = nil
                try context.save()
            }
        }
    }

    // Helper method to get current username
    private func getCurrentUsername() async -> String {
        do {
            let context = await coreDataStack.viewContext
            return try await context.perform {
                let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
                fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
                fetchRequest.fetchLimit = 1
                let users = try context.fetch(fetchRequest)
                if let currentUser = users.first, let username = currentUser.username {
                    return username
                }
                return "Unknown User"
            }
        } catch {
            return "Unknown User"
        }
    }
    func updateProduct(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.updatedAt = Date()
            try context.save()
        }
    }
    func updateProductWithPrice(product: GroceryItem, price: Double, store: String, location: String?) async throws {
        let currentUsername = await getCurrentUsername()
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            // Find or create the location
            let locationEntity = try self.findOrCreateLocation(context: context, name: store, address: location)
            // Check if a price already exists for this product at this store
            let existingPrices = productInContext.prices as? Set<GroceryItemPrice> ?? Set()
            let existingPrice = existingPrices.first { priceEntity in
                priceEntity.store == store && priceEntity.location == locationEntity
            }
            if let existingPrice = existingPrice {
                // Update existing price
                existingPrice.price = price
                existingPrice.lastUpdated = Date()
                existingPrice.updatedBy = currentUsername
            } else {
                // Create new price entity
                let priceEntity = GroceryItemPrice(
                    context: context,
                    id: UUID().uuidString,
                    price: price,
                    currency: "USD",
                    store: store,
                    groceryItem: productInContext,
                    location: locationEntity,
                    updatedBy: currentUsername
                )
            }
            productInContext.updatedAt = Date()
            try context.save()

            // Update user reputation directly in the same context
            if let currentUser = try context.fetch(NSFetchRequest<UserEntity>(entityName: "UserEntity")).first(where: { $0.username == currentUsername }) {
                // Increment updates count
                currentUser.updates += 1

                // Update level based on new count
                let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(currentUser.updates))
                currentUser.level = newLevel.name

                // Save the context to persist the reputation update
                try context.save()

                print("✅ REPUTATION UPDATE: Price update - user \(currentUsername): \(currentUser.updates) updates, level: \(newLevel.name)")
            } else {
                print("⚠️ WARNING: Could not find current user for reputation update")
            }
        }
    }
    func deleteProduct(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            // Remove all relationships before deletion to prevent cascade issues
            // Remove tag relationships
            productInContext.tags = NSSet()
            // Remove location relationships (this should not delete locations due to Nullify rule)
            productInContext.locations = NSSet()
            // Prices will be automatically deleted due to Cascade rule
            context.delete(productInContext)
            try context.save()
        }
    }
    func removeProductFromShoppingList(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isInShoppingList = false
            try context.save()
        }
    }
    func toggleProductCompletion(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isCompleted.toggle()
            try context.save()
        }
    }
    func addProductToShoppingList(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isInShoppingList = true
            productInContext.isCompleted = false // Reset completion status when adding to list
            try context.save()
        }
    }
    func fetchFavoriteProducts() async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.predicate = NSPredicate(format: "isFavorite == YES")
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.createdAt, ascending: false)]
            return try context.fetch(request)
        }
    }
    func addProductToFavorites(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isFavorite = true
            try context.save()
        }
    }
    func removeProductFromFavorites(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isFavorite = false
            try context.save()
        }
    }
    func toggleProductFavorite(_ product: GroceryItem) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            productInContext.isFavorite.toggle()
            try context.save()
        }
    }
    func searchProducts(by name: String) async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.predicate = NSPredicate(format: "productName CONTAINS[cd] %@", name)
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.productName, ascending: true)]
            return try context.fetch(request)
        }
    }
    func searchProductsByBarcode(_ barcode: String) async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.predicate = NSPredicate(format: "barcode == %@", barcode)
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.productName, ascending: true)]
            return try context.fetch(request)
        }
    }
    // MARK: - Tag Methods
    func fetchAllTags() async throws -> [Tag] {
        // Ensure tags are seeded before fetching
        try await coreDataStack.ensureTagsSeeded()
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<Tag> = Tag.fetchRequest()
            request.sortDescriptors = [NSSortDescriptor(keyPath: \Tag.name, ascending: true)]
            return try context.fetch(request)
        }
    }
    func createTag(id: String, name: String, color: String) async throws -> Tag {
        let objectID = try await coreDataStack.performBackgroundTask { context in
            let tag = Tag(context: context, id: id, name: name, color: color)
            try context.save()
            return tag.objectID
        }
        let viewContext = await coreDataStack.viewContext
        return try await viewContext.perform {
            return try viewContext.existingObject(with: objectID) as! Tag
        }
    }
    func updateTag(_ tag: Tag) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = tag.objectID
            let tagInContext = try context.existingObject(with: objectID) as! Tag
            tagInContext.updatedAt = Date()
            try context.save()
        }
    }
    func addTagsToProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            // Get the tags in the current context
            let tagObjectIDs = tags.map { $0.objectID }
            let tagsInContext = try tagObjectIDs.map { try context.existingObject(with: $0) as! Tag }
            // Add tags to product
            let currentTags = productInContext.tags as? Set<Tag> ?? Set()
            let newTags = currentTags.union(Set(tagsInContext))
            productInContext.tags = NSSet(set: newTags)
            try context.save()
        }
    }

    func replaceTagsForProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            // Get the tags in the current context
            let tagObjectIDs = tags.map { $0.objectID }
            let tagsInContext = try tagObjectIDs.map { try context.existingObject(with: $0) as! Tag }
            // Replace tags for product
            productInContext.tags = NSSet(set: Set(tagsInContext))
            try context.save()
        }
    }
    func removeTagsFromProduct(_ product: GroceryItem, tags: [Tag]) async throws {
        try await coreDataStack.performBackgroundTask { context in
            let objectID = product.objectID
            let productInContext = try context.existingObject(with: objectID) as! GroceryItem
            // Get the tags in the current context
            let tagObjectIDs = tags.map { $0.objectID }
            let tagsInContext = try tagObjectIDs.map { try context.existingObject(with: $0) as! Tag }
            // Remove tags from product
            let currentTags = productInContext.tags as? Set<Tag> ?? Set()
            let newTags = currentTags.subtracting(Set(tagsInContext))
            productInContext.tags = NSSet(set: newTags)
            try context.save()
        }
    }
        func searchProductsByTag(_ tag: Tag) async throws -> [GroceryItem] {
        // Use viewContext through the actor
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            request.predicate = NSPredicate(format: "ANY tags == %@", tag)
            request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.productName, ascending: true)]
            return try context.fetch(request)
        }
    }
    func initializeDefaultTags() async throws {
        // Use the new seeded data approach
        try await coreDataStack.performBackgroundTask { context in
            try TagSeedData.seedTags(in: context)
        }
    }
    func getAllStores() async throws -> [String] {
        let context = await coreDataStack.viewContext
        return try await context.perform {
            let request: NSFetchRequest<Location> = Location.fetchRequest()
            let locations = try context.fetch(request)
            return locations.compactMap { $0.name }.filter { !$0.isEmpty }
        }
    }
    func getItemPriceAtStore(item: GroceryItem, store: String) async throws -> Double? {
        let context = await coreDataStack.viewContext
        return try await context.perform { [self] in
            // Get all prices for this item
            let prices = item.priceArray
            // Find the price for this specific store that's not older than 2 weeks
            let storePrice = prices.first { price in
                price.store == store && self.isPriceRecent(price.lastUpdated)
            }
            return storePrice?.price
        }
    }

    func getItemPriceAndShopperAtStore(item: GroceryItem, store: String) async throws -> (price: Double?, shopper: String?) {
        let context = await coreDataStack.viewContext
        return try await context.perform { [self] in
            // Get all prices for this item
            let prices = item.priceArray
            // Find the price for this specific store that's not older than 2 weeks
            let storePrice = prices.first { price in
                price.store == store && self.isPriceRecent(price.lastUpdated)
            }

            // Log if we found an outdated price
            if let outdatedPrice = prices.first(where: { price in
                price.store == store && !self.isPriceRecent(price.lastUpdated)
            }) {
                print("Repository: Excluding outdated price for \(item.productName ?? "Unknown") at \(store) - last updated: \(outdatedPrice.lastUpdated?.description ?? "Unknown")")
            }

            return (storePrice?.price, storePrice?.updatedBy)
        }
    }

    // Helper method to check if a price is recent (within 2 weeks)
    private func isPriceRecent(_ lastUpdated: Date?) -> Bool {
        guard let lastUpdated = lastUpdated else { return false }
        let twoWeeksAgo = Calendar.current.date(byAdding: .day, value: -14, to: Date()) ?? Date()
        return lastUpdated >= twoWeeksAgo
    }
}
//
//  GroceryItem+CoreDataClass.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/7/25.
//
import Foundation
import CoreData
@objc(GroceryItem)
public class GroceryItem: NSManagedObject {
}
//
//  GroceryItemPrice+CoreDataClass.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import Foundation
import CoreData
@objc(GroceryItemPrice)
public class GroceryItemPrice: NSManagedObject {
}
//
//  PersistenceController.swift
//  CartWise
//
//  Created by Alex Kumar on 7/13/25.
//
import CoreData
struct PersistenceController {
    static let shared = PersistenceController()
    let container: NSPersistentContainer
    init() {
        container = NSPersistentContainer(name: "ProductModel")
        container.loadPersistentStores { description, error in
            if let error = error as NSError? {
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        }
    }
}
//
//  ReputationCardView.swift
//  CartWise
//
//  Created by CartWise Development Team on 12/19/24.
//

import SwiftUI

struct ReputationCardView: View {
    let updates: Int
    let level: String
    @State private var progressValue: Double = 0.0

    private var currentLevel: ShopperLevel {
        ReputationSystem.shared.getCurrentLevel(updates: updates)
    }

    private var nextLevel: ShopperLevel? {
        ReputationSystem.shared.getNextLevel(updates: updates)
    }

    private var progressToNextLevel: Double {
        ReputationSystem.shared.getProgressToNextLevel(updates: updates)
    }

    private var updatesToNextLevel: Int {
        ReputationSystem.shared.getUpdatesToNextLevel(updates: updates)
    }

    var body: some View {
        VStack(spacing: 20) {
            // Level Badge
            LevelBadgeView(level: currentLevel)

            // Level Info
            VStack(spacing: 8) {
                Text(currentLevel.name)
                    .font(.poppins(size: 20, weight: .bold))
                    .foregroundColor(AppColors.textPrimary)

                Text(currentLevel.description)
                    .font(.poppins(size: 14, weight: .regular))
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 20)
            }

            // Statistics
            StatisticsView(updates: updates)

            // Progress Section
            if let nextLevel = nextLevel {
                ProgressSectionView(
                    currentLevel: currentLevel,
                    nextLevel: nextLevel,
                    progress: progressToNextLevel,
                    updatesToNext: updatesToNextLevel
                )
            } else {
                // Max level reached
                MaxLevelView()
            }
        }
        .padding(24)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.06), radius: 8, x: 0, y: 4)
        )
        .onAppear {
            withAnimation(.easeInOut(duration: 1.0)) {
                progressValue = progressToNextLevel
            }
        }
    }
}

// MARK: - Level Badge View
struct LevelBadgeView: View {
    let level: ShopperLevel

    var body: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [
                            level.color.opacity(0.2),
                            level.color.opacity(0.1)
                        ]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 80, height: 80)

            Image(systemName: level.icon)
                .font(.system(size: 32, weight: .medium))
                .foregroundColor(level.color)
        }
    }
}

// MARK: - Statistics View
struct StatisticsView: View {
    let updates: Int

    var body: some View {
        VStack(spacing: 12) {
            Text("\(updates)")
                .font(.poppins(size: 32, weight: .bold))
                .foregroundColor(AppColors.accentGreen)

            Text("Price Updates")
                .font(.poppins(size: 14, weight: .medium))
                .foregroundColor(.gray)
        }
        .padding(.vertical, 8)
    }
}

// MARK: - Progress Section View
struct ProgressSectionView: View {
    let currentLevel: ShopperLevel
    let nextLevel: ShopperLevel
    let progress: Double
    let updatesToNext: Int

    var body: some View {
        VStack(spacing: 16) {
            // Progress Bar
            VStack(spacing: 8) {
                HStack {
                    Text("Progress to \(nextLevel.name)")
                        .font(.poppins(size: 14, weight: .medium))
                        .foregroundColor(AppColors.textPrimary)

                    Spacer()

                    Text("\(Int(progress * 100))%")
                        .font(.poppins(size: 14, weight: .semibold))
                        .foregroundColor(AppColors.accentGreen)
                }

                ProgressBarView(progress: progress)
            }

            // Updates needed
            HStack(spacing: 8) {
                Image(systemName: "arrow.up.circle.fill")
                    .foregroundColor(AppColors.accentGreen)
                    .font(.system(size: 16))

                Text("\(updatesToNext) more updates to reach \(nextLevel.name)")
                    .font(.poppins(size: 12, weight: .medium))
                    .foregroundColor(.gray)

                Spacer()
            }
        }
    }
}

// MARK: - Progress Bar View
struct ProgressBarView: View {
    let progress: Double
    @State private var animatedProgress: Double = 0.0

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 8)

                // Progress
                RoundedRectangle(cornerRadius: 8)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                AppColors.accentGreen,
                                AppColors.accentGreen.opacity(0.8)
                            ]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(width: geometry.size.width * animatedProgress, height: 8)
                    .animation(.easeInOut(duration: 1.0), value: animatedProgress)
            }
        }
        .frame(height: 8)
        .onAppear {
            animatedProgress = progress
        }
        .onChange(of: progress) { _, newValue in
            animatedProgress = newValue
        }
    }
}

// MARK: - Max Level View
struct MaxLevelView: View {
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: "star.circle.fill")
                .font(.system(size: 32))
                .foregroundColor(.yellow)

            Text("Maximum Level Reached!")
                .font(.poppins(size: 16, weight: .bold))
                .foregroundColor(AppColors.textPrimary)

            Text("You've achieved the highest level in the CartWise community!")
                .font(.poppins(size: 12, weight: .medium))
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
        }
        .padding(.vertical, 8)
    }
}

#Preview {
    ReputationCardView(updates: 75, level: "Expert Shopper")
        .padding()
        .background(AppColors.backgroundSecondary)
}
//
//  PriceComparisonView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/19/25.
//
import SwiftUI
import Foundation
struct PriceComparisonView: View {
    let priceComparison: PriceComparison?
    let isLoading: Bool
    let onRefresh: () async -> Void
    let onLocalComparison: () async -> Void
    @State private var showingShareExperience = false
    var body: some View {
        VStack(spacing: 12) {
            // Header
            HStack {
                Text("Price Comparison")
                    .font(.system(size: 15, weight: .regular))
                    .foregroundColor(.gray)
                Spacer()
                if isLoading {
                    ProgressView()
                        .scaleEffect(0.8)
                } else {
                    HStack(spacing: 12) {
                        Button(action: {
                            showingShareExperience = true
                        }) {
                            Image(systemName: "bubble.left.and.bubble.right")
                                .foregroundColor(.blue)
                        }
                        Button(action: {
                            Task {
                                await onLocalComparison()
                            }
                        }) {
                            Image(systemName: "arrow.clockwise")
                                .foregroundColor(.blue)
                        }
                    }
                }
            }
            .padding(.horizontal)
            .padding(.top, 8)

            // Availability threshold info
            HStack {
                Text("Only showing stores with 85%+ of your items")
                    .font(.caption)
                    .foregroundColor(.secondary)

                Spacer()
            }
            .padding(.horizontal)
            .padding(.top, 4)

            // Price comparison content
            if let comparison = priceComparison {
                if comparison.storePrices.isEmpty {
                    VStack(spacing: 8) {
                        Text("No stores meet the 85% availability threshold")
                            .font(.subheadline)
                            .foregroundColor(.secondary)

                        Text("Add more items with store information or try stores with better inventory")
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .multilineTextAlignment(.center)
                    }
                    .padding()
                } else {
                    VStack(spacing: 8) {
                        // Best store summary
                        if let bestStore = comparison.bestStore {
                            HStack {
                                Text("Best: \(bestStore)")
                                    .font(.subheadline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.green)
                                Spacer()
                                Text("$\(String(format: "%.2f", comparison.bestTotalPrice))")
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.green)
                            }
                            .padding(.horizontal)
                            .padding(.vertical, 8)
                            .background(Color.green.opacity(0.1))
                            .cornerRadius(8)
                        }
                        // Store rankings
                        ForEach(Array(comparison.storePrices.enumerated()), id: \.offset) { index, storePrice in
                            StorePriceRow(
                                storePrice: storePrice,
                                isBest: storePrice.store == comparison.bestStore,
                                rank: index + 1
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            } else {
                VStack(spacing: 8) {
                    Text("No price comparison available")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    Text("Scan barcodes to add items with store information")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding()
            }
        }
        .padding(.vertical, 8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        .sheet(isPresented: $showingShareExperience) {
            ShareExperienceView(priceComparison: priceComparison)
        }
    }
}
struct StorePriceRow: View {
    let storePrice: StorePrice
    let isBest: Bool
    let rank: Int
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                // Rank
                Text("\(rank).")
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(.secondary)
                    .frame(width: 20, alignment: .leading)
                // Store name
                Text(storePrice.store)
                    .font(.subheadline)
                    .fontWeight(isBest ? .semibold : .regular)
                    .foregroundColor(isBest ? .green : .primary)
                Spacer()
                // Price
                VStack(alignment: .trailing, spacing: 2) {
                    Text("$\(String(format: "%.2f", storePrice.totalPrice))")
                        .font(.subheadline)
                        .fontWeight(isBest ? .bold : .medium)
                        .foregroundColor(isBest ? .green : .primary)
                    Text("\(storePrice.availableItems)/\(storePrice.availableItems + storePrice.unavailableItems) items")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }

        }
        .padding(.vertical, 4)
    }
}
//
//  FavoriteItemsView.swift
//  CartWise
//
//  Created by AI Assistant on 7/17/25.
//
import SwiftUI
struct FavoriteItemsView: View {
    @EnvironmentObject var productViewModel: ProductViewModel
    @State private var showingProductDetail = false
    @State private var selectedProduct: GroceryItem?
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // Enhanced Header
            HStack {
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                gradient: Gradient(colors: [
                                    AppColors.accentGreen.opacity(0.2),
                                    AppColors.accentGreen.opacity(0.1)
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 40, height: 40)
                    Image(systemName: "heart.fill")
                        .foregroundColor(AppColors.accentGreen)
                        .font(.system(size: 18, weight: .medium))
                }

                VStack(alignment: .leading, spacing: 2) {
                    Text("My Favorite Items")
                        .font(.poppins(size: 20, weight: .bold))
                        .foregroundColor(AppColors.textPrimary)

                    Text("Manage your favorite items")
                        .font(.poppins(size: 14, weight: .regular))
                        .foregroundColor(.gray)
                }

                Spacer()
                Text("\(productViewModel.favoriteProducts.count) items")
                    .font(.poppins(size: 15, weight: .medium))
                    .foregroundColor(.gray)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.gray.opacity(0.1))
                    )
            }
            .padding(.horizontal, 20)
            .padding(.top, 8)

            // Divider line
            Divider()
                .background(Color.gray.opacity(0.3))
                .padding(.horizontal, 20)
                .padding(.vertical, 8)

            // Enhanced Favorites List
            if productViewModel.favoriteProducts.isEmpty {
                // Enhanced Empty State
                VStack(spacing: 20) {
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    gradient: Gradient(colors: [
                                        Color.gray.opacity(0.1),
                                        Color.gray.opacity(0.05)
                                    ]),
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 80, height: 80)
                        Image(systemName: "heart")
                            .font(.system(size: 36, weight: .light))
                            .foregroundColor(.gray.opacity(0.6))
                    }
                    VStack(spacing: 8) {
                        Text("No favorite items yet")
                            .font(.poppins(size: 20, weight: .semibold))
                            .foregroundColor(.gray)
                        Text("Add items to your favorites to see them here")
                            .font(.poppins(size: 15, weight: .regular))
                            .foregroundColor(.gray.opacity(0.7))
                            .multilineTextAlignment(.center)
                            .padding(.horizontal, 20)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 40)
            } else {
                // Enhanced Favorites List
                ScrollView {
                    LazyVStack(spacing: 16) {
                        ForEach(productViewModel.favoriteProducts, id: \.objectID) { product in
                            FavoriteItemRow(
                                product: product,
                                onTap: {
                                    selectedProduct = product
                                    showingProductDetail = true
                                },
                                onRemoveFromFavorites: {
                                    Task {
                                        await productViewModel.removeProductFromFavorites(product)
                                    }
                                }
                            )
                        }
                    }
                    .padding(.horizontal, 20)
                }
                .frame(maxHeight: 320)
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 24)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.08), radius: 16, x: 0, y: 8)
        )
        .padding(.vertical, 16)
        .sheet(isPresented: $showingProductDetail) {
            if let product = selectedProduct {
                ProductDetailView(product: product, selectedLocation: nil)
            }
        }
        .task {
            await productViewModel.loadFavoriteProducts()
        }
    }
}
struct FavoriteItemRow: View {
    let product: GroceryItem
    let onTap: () -> Void
    let onRemoveFromFavorites: () -> Void
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 16) {
                                            // Product image
                            ProductImageView(
                                product: product,
                                size: CGSize(width: 56, height: 56),
                                cornerRadius: 12,
                                showSaleBadge: false
                            )
                            .shadow(color: Color.black.opacity(0.05), radius: 4, x: 0, y: 2)
                VStack(alignment: .leading, spacing: 6) {
                    Text(product.productName ?? "Unknown Product")
                        .font(.poppins(size: 17, weight: .semibold))
                        .foregroundColor(.primary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let brand = product.brand, !brand.isEmpty {
                        Text(brand)
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                            .lineLimit(1)
                    }
                    if let store = product.store, !store.isEmpty {
                        HStack(spacing: 4) {
                            Image(systemName: "mappin.circle.fill")
                                .font(.system(size: 12))
                                .foregroundColor(AppColors.accentGreen)
                            Text(store)
                                .font(.poppins(size: 12, weight: .medium))
                                .foregroundColor(AppColors.accentGreen)
                                .lineLimit(1)
                        }
                    }
                }
                Spacer()
                VStack(alignment: .trailing, spacing: 8) {
                    if product.price > 0 {
                        Text("$\(String(format: "%.2f", product.price))")
                            .font(.poppins(size: 17, weight: .bold))
                            .foregroundColor(AppColors.accentGreen)
                    }
                    // Enhanced Remove from favorites button
                    Button(action: onRemoveFromFavorites) {
                        ZStack {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        gradient: Gradient(colors: [
                                            AppColors.accentGreen.opacity(0.2),
                                            AppColors.accentGreen.opacity(0.1)
                                        ]),
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 32, height: 32)
                            Image(systemName: "heart.fill")
                                .foregroundColor(AppColors.accentGreen)
                                .font(.system(size: 14, weight: .medium))
                        }
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(16)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color.white)
                    .shadow(color: Color.black.opacity(0.06), radius: 8, x: 0, y: 4)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
#Preview {
    FavoriteItemsView()
}
//
//  SplashScreenView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 8/5/25.
//

import SwiftUI

struct SplashScreenView: View {
    var body: some View {
        ZStack {
            // Background
            Color.white
                .ignoresSafeArea()

            VStack(spacing: 8) {
                // CartWise logo
                Text("CartWise")
                    .font(.system(size: 52, weight: .bold, design: .default))
                    .foregroundColor(Color(red: 0.2, green: 0.8, blue: 0.2))

                // Tagline
                Text("Smart Shopping Made Simple")
                    .font(.system(size: 16, weight: .medium, design: .default))
                    .foregroundColor(.gray)
            }
        }
    }
}

#Preview {
    SplashScreenView()
}
//
//  LoginView.swift
//  CartWise
//
//  Created by Alex Kumar on 7/12/25.
//
import SwiftUI
struct LoginView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var viewModel: AuthViewModel
    @AppStorage("isLoggedIn") private var isLoggedIn: Bool = false
    @State private var username = ""
    @State private var password = ""
    init() {
        _viewModel = StateObject(wrappedValue: AuthViewModel(context: PersistenceController.shared.container.viewContext))
    }
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Shopping Cart Icon
                Image(systemName: "cart.fill")
                    .font(.system(size: 60))
                    .foregroundColor(AppColors.accentGreen)
                    .padding(.top, 50)
                // App Logo/Title
                Text("CartWise")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(AppColors.textPrimary)
                    .padding(.top, 10)
                Spacer()
                VStack(spacing: 20) {
                    // Username Field
                    VStack(alignment: .leading, spacing: 5) {
                        Text("Username")
                            .font(.headline)
                            .foregroundColor(AppColors.textPrimary)
                        TextField("Enter username", text: $username)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .autocapitalization(.none)
                            .textContentType(.username)
                    }
                    // Password Field
                    VStack(alignment: .leading, spacing: 5) {
                        Text("Password")
                            .font(.headline)
                            .foregroundColor(AppColors.textPrimary)
                        SecureField("Enter password", text: $password)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .textContentType(.password)
                    }
                }
                .padding(.horizontal)
                // Error Message
                if let error = viewModel.error {
                    Text(error)
                        .foregroundColor(AppColors.accentRed)
                        .font(.caption)
                        .padding(.horizontal)
                }
                // Login Button
                Button(action: {
                    Task {
                        print("Login button tapped with username: \(username)")
                        await viewModel.login(username: username, password: password)
                        print("Login completed. User: \(String(describing: viewModel.user)), Error: \(String(describing: viewModel.error))")
                        if viewModel.user != nil {
                            isLoggedIn = true
                            print("User logged in successfully")
                        }
                    }
                }) {
                    if viewModel.isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: AppColors.textSecondary))
                            .scaleEffect(0.8)
                    } else {
                        Text("Log In")
                            .fontWeight(.semibold)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                .frame(maxWidth: .infinity)
                .frame(height: 50)
                .background(AppColors.accentGreen)
                .cornerRadius(10)
                .padding(.horizontal)
                .disabled(viewModel.isLoading || username.isEmpty || password.isEmpty)
                // Sign Up Link
                NavigationLink("Don't have an account? Sign Up", destination: SignUpView())
                    .foregroundColor(AppColors.textPrimary)
                    .font(.system(size: 16, weight: .medium))
                    .padding(.top, 10)
                Spacer()
            }
            .background(AppColors.backgroundPrimary)
            .navigationTitle("Log In")
            .navigationBarHidden(true)
        }
    }
}
// Preview
struct LoginView_Previews: PreviewProvider {
    static var previews: some View {
        LoginView()
            .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
    }
}
//
//  LocationPickerView.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import SwiftUI
import CoreData
struct LocationPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @Binding var selectedLocation: Location?
    @State private var searchText = ""
    @State private var locations: [Location] = []
    @State private var isLoading = true
    @State private var showAddLocation = false
    var filteredLocations: [Location] {
        if searchText.isEmpty {
            return locations
        }
        return locations.filter { location in
            let nameMatch = location.name?.localizedCaseInsensitiveContains(searchText) == true
            let cityMatch = location.city?.localizedCaseInsensitiveContains(searchText) == true
            let stateMatch = location.state?.localizedCaseInsensitiveContains(searchText) == true
            return nameMatch || cityMatch || stateMatch
        }
    }
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Search Bar
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField("Search locations...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                .padding(.horizontal)
                .padding(.top)
                if isLoading {
                    Spacer()
                    VStack(spacing: 12) {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading locations...")
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                    }
                    Spacer()
                } else if locations.isEmpty {
                    // Empty State
                    Spacer()
                    VStack(spacing: 16) {
                        Image(systemName: "location.slash")
                            .font(.system(size: 48))
                            .foregroundColor(.gray.opacity(0.6))
                        VStack(spacing: 8) {
                            Text("No Locations Yet")
                                .font(.poppins(size: 18, weight: .semibold))
                                .foregroundColor(AppColors.textPrimary)
                            Text("Add your first location to get started")
                                .font(.poppins(size: 14, weight: .regular))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        Button(action: {
                            showAddLocation = true
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: "plus.circle.fill")
                                    .font(.system(size: 16, weight: .medium))
                                Text("Add First Location")
                                    .font(.poppins(size: 16, weight: .semibold))
                            }
                            .foregroundColor(AppColors.accentGreen)
                            .padding(.horizontal, 20)
                            .padding(.vertical, 12)
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(AppColors.accentGreen, lineWidth: 2)
                            )
                        }
                    }
                    Spacer()
                } else {
                    // Locations List
                    List {
                        ForEach(filteredLocations, id: \.id) { location in
                            Button(action: {
                                selectedLocation = location
                                dismiss()
                            }) {
                                HStack(spacing: 12) {
                                    // Location Icon
                                    ZStack {
                                        Circle()
                                            .fill(AppColors.accentGreen.opacity(0.1))
                                            .frame(width: 40, height: 40)
                                        Image(systemName: "location.circle.fill")
                                            .font(.system(size: 20))
                                            .foregroundColor(AppColors.accentGreen)
                                    }
                                    // Location Details
                                    VStack(alignment: .leading, spacing: 4) {
                                        HStack(spacing: 8) {
                                            Text(location.name ?? "Unknown Location")
                                                .font(.poppins(size: 16, weight: .semibold))
                                                .foregroundColor(AppColors.textPrimary)
                                            if location.isDefault {
                                                Image(systemName: "star.fill")
                                                    .font(.system(size: 12))
                                                    .foregroundColor(.yellow)
                                            }
                                            if location.favorited {
                                                Image(systemName: "heart.fill")
                                                    .font(.system(size: 12))
                                                    .foregroundColor(.red)
                                            }
                                        }
                                        Text(formatAddress(location))
                                            .font(.poppins(size: 14, weight: .regular))
                                            .foregroundColor(.gray)
                                            .lineLimit(1)
                                    }
                                    Spacer()
                                    // Checkmark if selected
                                    if selectedLocation?.id == location.id {
                                        Image(systemName: "checkmark")
                                            .font(.system(size: 16, weight: .medium))
                                            .foregroundColor(AppColors.accentGreen)
                                    }
                                }
                                .padding(.vertical, 4)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                    .listStyle(PlainListStyle())
                }
            }
            .navigationTitle("Select Location")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.accentGreen)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showAddLocation = true
                    }) {
                        Image(systemName: "plus")
                            .foregroundColor(AppColors.accentGreen)
                    }
                }
            }
        }
        .sheet(isPresented: $showAddLocation) {
            AddLocationView()
        }
        .task {
            await loadLocations()
        }
        .onReceive(NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)) { _ in
            Task {
                await loadLocations()
            }
        }
    }
    private func loadLocations() async {
        isLoading = true
        do {
            // Get current user
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try viewContext.fetch(fetchRequest)
            guard let currentUser = users.first else { return }
            // Fetch user's locations
            let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
            locationFetchRequest.predicate = NSPredicate(format: "user == %@", currentUser)
            locationFetchRequest.sortDescriptors = [
                NSSortDescriptor(keyPath: \Location.isDefault, ascending: false),
                NSSortDescriptor(keyPath: \Location.favorited, ascending: false),
                NSSortDescriptor(keyPath: \Location.name, ascending: true)
            ]
            let fetchedLocations = try viewContext.fetch(locationFetchRequest)
            await MainActor.run {
                self.locations = fetchedLocations
                self.isLoading = false
            }
        } catch {
            print("Error loading locations: \(error)")
            await MainActor.run {
                self.isLoading = false
            }
        }
    }
    private func formatAddress(_ location: Location) -> String {
        var components: [String] = []
        if let city = location.city, !city.isEmpty {
            components.append(city)
        }
        if let state = location.state, !state.isEmpty {
            components.append(state)
        }
        if let zipCode = location.zipCode, !zipCode.isEmpty {
            components.append(zipCode)
        }
        return components.isEmpty ? "No address" : components.joined(separator: ", ")
    }
}
//
//  ShareExperienceView.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import SwiftUI
struct ShareExperienceView: View {
    let priceComparison: PriceComparison?
    @StateObject private var viewModel = SocialFeedViewModel()
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @State private var comment = ""
    @State private var rating: Int16 = 0
    @State private var selectedType = "price_update"
    // Optional additional information
    @State private var selectedProduct: GroceryItem?
    @State private var selectedLocation: Location?
    @State private var showingProductPicker = false
    @State private var showingLocationPicker = false
    private let types = [
        ("price_update", "Price Update"),
        ("store_review", "Store Review"),
        ("general", "General Comment")
    ]
    init(priceComparison: PriceComparison?) {
        self.priceComparison = priceComparison
        // Initialize state values based on context
        _viewModel = StateObject(wrappedValue: SocialFeedViewModel())
        _selectedType = State(initialValue: priceComparison == nil ? "store_review" : "price_update")
    }
    var body: some View {
        NavigationView {
            Form {
                Section("Experience Details") {
                    Picker("Type", selection: $selectedType) {
                        ForEach(types, id: \.0) { type in
                            Text(type.1).tag(type.0)
                        }
                    }
                    .pickerStyle(.menu)
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Rating")
                            .font(.headline)
                        HStack(spacing: 12) {
                            ForEach(1...5, id: \.self) { star in
                                Button(action: {
                                    // If tapping the same star, clear the rating, otherwise set to the tapped star
                                    rating = rating == Int16(star) ? 0 : Int16(star)
                                }) {
                                    Image(systemName: star <= rating ? "star.fill" : "star")
                                        .foregroundColor(star <= rating ? .orange : .gray)
                                        .font(.title2)
                                        .frame(width: 32, height: 32)
                                        .contentShape(Rectangle())
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                }
                if let comparison = priceComparison, let bestStore = comparison.bestStore {
                    Section("Price Comparison Info") {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Best Store: \(bestStore)")
                                .font(.headline)
                                .foregroundColor(.green)
                            Text("Total Price: $\(String(format: "%.2f", comparison.bestTotalPrice))")
                                .font(.subheadline)
                                .foregroundColor(.primary)
                            if !comparison.storePrices.isEmpty {
                                Text("Available at \(comparison.storePrices.count) stores")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                // Optional Product Information
                if selectedType == "price_update" {
                    Section("Product Information (Optional)") {
                        Button(action: {
                            showingProductPicker = true
                        }) {
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Product")
                                        .font(.headline)
                                    Text(selectedProduct?.productName ?? "Select a product")
                                        .font(.subheadline)
                                        .foregroundColor(selectedProduct == nil ? .gray : .primary)
                                }
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .foregroundColor(.gray)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        if selectedProduct != nil {
                            Button("Clear Product") {
                                selectedProduct = nil
                            }
                            .foregroundColor(.red)
                        }
                    }
                }
                // Optional Store Information
                if selectedType == "store_review" {
                    Section("Store Information (Optional)") {
                        Button(action: {
                            showingLocationPicker = true
                        }) {
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Store")
                                        .font(.headline)
                                    Text(selectedLocation?.name ?? "Select a store")
                                        .font(.subheadline)
                                        .foregroundColor(selectedLocation == nil ? .gray : .primary)
                                }
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .foregroundColor(.gray)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        if selectedLocation != nil {
                            Button("Clear Store") {
                                selectedLocation = nil
                            }
                            .foregroundColor(.red)
                        }
                    }
                }
                Section("Your Comment") {
                    TextEditor(text: $comment)
                        .frame(minHeight: 100)
                        .onAppear {
                            if let comparison = priceComparison, let bestStore = comparison.bestStore {
                                comment = "Found great prices at \(bestStore)! Total: $\(String(format: "%.2f", comparison.bestTotalPrice))"
                            }
                        }
                }
            }
            .navigationTitle("Share Experience")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Post") {
                        postExperience()
                    }
                    .disabled(comment.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
            .sheet(isPresented: $showingProductPicker) {
                ProductPickerView(selectedProduct: $selectedProduct)
            }
            .sheet(isPresented: $showingLocationPicker) {
                LocationPickerView(selectedLocation: $selectedLocation)
            }
        }
    }
    private func postExperience() {
        // Create enhanced comment with optional information
        var enhancedComment = comment.trimmingCharacters(in: .whitespacesAndNewlines)
        // Add product information if available
        if let product = selectedProduct {
            enhancedComment += "\n\nProduct: \(product.productName ?? "Unknown")"
            if let brand = product.brand, !brand.isEmpty {
                enhancedComment += " (\(brand))"
            }
        }
        // Add store information if available
        if let location = selectedLocation {
            enhancedComment += "\nStore: \(location.name ?? "Unknown")"
            if let address = location.address, !address.isEmpty {
                enhancedComment += " (\(address))"
            }
        }
        // Get current user from the same context
        let currentUser = viewModel.getCurrentUser()
        viewModel.createExperience(
            comment: enhancedComment,
            rating: rating,
            type: selectedType,
            groceryItem: selectedProduct,
            location: selectedLocation,
            user: currentUser
        )
        dismiss()
    }
}
#Preview {
    ShareExperienceView(priceComparison: nil)
}
//
//  YourListView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//  Edited by Brenna Wilson on 7/10/25 - 7/13/25
//  Enhanced with AI assistance from Cursor AI for UI improvements and functionality.
//  This saved me 6-9 hours of work learning swift UI syntax.
//
import SwiftUI
struct YourListView: View {
    @EnvironmentObject var productViewModel: ProductViewModel
    @State private var suggestedStore: String = "Whole Foods Market"
    @State private var storeAddress: String = "1701 Wewatta St."
    @State private var total: Double = 0.00
    @State private var allItemsChecked: Bool = false
    @State private var isEditing: Bool = false
    @State private var selectedItemsForDeletion: Set<String> = []
    @State private var showingAddProductModal = false
    @State private var showingRatingPrompt: Bool = false
    @State private var showingDuplicateAlert = false
    @State private var duplicateProductName = ""
    @State private var showingCheckAllConfirmation = false
    var body: some View {
        NavigationStack {
            MainContentView(
                isEditing: $isEditing,
                allItemsChecked: $allItemsChecked,
                selectedItemsForDeletion: $selectedItemsForDeletion,
                suggestedStore: suggestedStore,
                storeAddress: storeAddress,
                total: total,
                showingRatingPrompt: $showingRatingPrompt,
                showingAddProductModal: $showingAddProductModal,
                showingCheckAllConfirmation: $showingCheckAllConfirmation
            )
            .navigationTitle("Your Shopping List")
            .sheet(isPresented: $showingRatingPrompt) {
                RatingPromptView()
            }
            .sheet(isPresented: $showingAddProductModal) {
                SmartAddProductModal(onAdd: addProductToSystem)
                    .presentationDetents([.large])
                    .presentationDragIndicator(.visible)
                    .ignoresSafeArea(.keyboard, edges: .bottom)
            }
            .alert("Duplicate Product", isPresented: $showingDuplicateAlert) {
                Button("OK") {
                    showingDuplicateAlert = false
                }
            } message: {
                Text("A product named \"\(duplicateProductName)\" already exists in your list.")
            }
            .alert("All done shopping?", isPresented: $showingCheckAllConfirmation) {
                Button("Cancel", role: .cancel) {
                    // Do nothing, just dismiss the alert
                }
                Button("Clear List") {
                    Task {
                        await productViewModel.clearShoppingList()
                    }
                }
            } message: {
                Text("Want to clear your shopping list?")
            }
            .onAppear {
                Task {
                    // Always refresh shopping list when view appears to prevent stale data
                    await productViewModel.loadShoppingListProducts()
                    print("YourListView: Loaded \(productViewModel.products.count) shopping list products")
                    await productViewModel.loadLocalPriceComparison()
                    print("YourListView: Price comparison loaded: \(productViewModel.priceComparison?.storePrices.count ?? 0) stores")
                    if let comparison = productViewModel.priceComparison {
                        print("YourListView: Best store: \(comparison.bestStore ?? "None"), Total: $\(comparison.bestTotalPrice)")
                        for storePrice in comparison.storePrices {
                            print("YourListView: Store \(storePrice.store): $\(storePrice.totalPrice)")
                        }
                    }
                }
            }
        }
    }
    private func addProductToSystem(name: String, brand: String?, category: String?, price: Double? = nil) {
        Task {
            // Check for duplicate first
            if await productViewModel.isDuplicateProduct(name: name) {
                duplicateProductName = name
                showingDuplicateAlert = true
                return
            }
            // Proceed with creation if no duplicate
            if let brand = brand, !brand.isEmpty {
                await productViewModel.createProductForShoppingList(byName: name, brand: brand, category: category)
            } else {
                await productViewModel.createProductForShoppingList(byName: name, brand: nil, category: category)
            }
            // Refresh price comparison after adding product
            await productViewModel.loadLocalPriceComparison()
        }
    }
}
// Main Content View, edited by AI
struct MainContentView: View {
    @EnvironmentObject var productViewModel: ProductViewModel
    @Binding var isEditing: Bool
    @Binding var allItemsChecked: Bool
    @Binding var selectedItemsForDeletion: Set<String>
    let suggestedStore: String
    let storeAddress: String
    let total: Double
    @Binding var showingRatingPrompt: Bool
    @Binding var showingAddProductModal: Bool
    @Binding var showingCheckAllConfirmation: Bool
    // private func calculateTotal() -> Double {
    //     return productViewModel.products.reduce(0.0) { total, product in
    //         total + product.price
    //     }
    // }
    var body: some View {
        ZStack {
            // Background
            AppColors.backgroundSecondary
                .ignoresSafeArea()
            // Main Content
            VStack(alignment: .leading, spacing: 24) {
                // Item List Card
                ShoppingListCard(
                    isEditing: $isEditing,
                    allItemsChecked: $allItemsChecked,
                    selectedItemsForDeletion: $selectedItemsForDeletion,
                    showingRatingPrompt: $showingRatingPrompt,
                    showingAddProductModal: $showingAddProductModal,
                    showingCheckAllConfirmation: $showingCheckAllConfirmation
                )
                // Price Comparison Card
                PriceComparisonView(
                    priceComparison: productViewModel.priceComparison,
                    isLoading: productViewModel.isLoadingPriceComparison,
                    onRefresh: {
                        await productViewModel.loadLocalPriceComparison()
                    },
                    onLocalComparison: {
                        await productViewModel.loadLocalPriceComparison()
                    }
                )
                .padding(.horizontal)
                Spacer()
            }
            .padding(.top)
        }
    }
}
// Shopping List Card
struct ShoppingListCard: View {
    @EnvironmentObject var productViewModel: ProductViewModel
    @Binding var isEditing: Bool
    @Binding var allItemsChecked: Bool
    @Binding var selectedItemsForDeletion: Set<String>
    @Binding var showingRatingPrompt: Bool
    @Binding var showingAddProductModal: Bool
    @Binding var showingCheckAllConfirmation: Bool

    // Function to handle SwiftUI's native onDelete
    private func deleteItems(offsets: IndexSet) {
        // Capture the products to delete before any async operations
        let productsToDelete = offsets.compactMap { index in
            // Check bounds to prevent index out of range
            index < productViewModel.products.count ? productViewModel.products[index] : nil
        }

        Task {
            // Process deletions sequentially to avoid race conditions
            for product in productsToDelete {
                await productViewModel.removeProductFromShoppingList(product)
                // Small delay to allow UI to update between deletions
                try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 seconds
            }
        }
    }
    var body: some View {
        VStack(spacing: 12) {
            // Header
            HStack {
                if isEditing {
                    HStack(spacing: 16) {
                        Button(action: {
                            // Remove selected items from shopping list
                            for id in selectedItemsForDeletion {
                                if let product = productViewModel.products.first(where: { $0.id == id }) {
                                    Task {
                                        await productViewModel.removeProductFromShoppingList(product)
                                    }
                                }
                            }
                            isEditing = false
                            selectedItemsForDeletion.removeAll()
                        }) {
                            Text("Delete")
                                .font(.poppins(size: 15, weight: .regular))
                                .underline()
                                .foregroundColor(.red)
                        }
                        Button(action: {
                            if selectedItemsForDeletion.count == productViewModel.products.count {
                                selectedItemsForDeletion.removeAll()
                            } else {
                                selectedItemsForDeletion = Set(productViewModel.products.compactMap { $0.id })
                            }
                        }) {
                            Text(selectedItemsForDeletion.count == productViewModel.products.count ? "Deselect All" : "Select All")
                                .font(.poppins(size: 15, weight: .regular))
                                .underline()
                                .foregroundColor(.blue)
                        }
                    }
                    Spacer()
                    Button(action: {
                        isEditing = false
                        selectedItemsForDeletion.removeAll()
                    }) {
                        Text("Cancel")
                            .font(.poppins(size: 15, weight: .regular))
                            .underline()
                            .foregroundColor(.gray)
                    }
                } else {
                    Text("\(productViewModel.products.count) Items")
                        .font(.poppins(size: 15, weight: .regular))
                        .foregroundColor(.gray)
                    Spacer()
                    Button(action: {
                        isEditing.toggle()
                    }) {
                        Text("Edit")
                            .font(.poppins(size: 15, weight: .regular))
                            .underline()
                            .foregroundColor(.gray)
                    }
                }
            }
            .padding(.horizontal)
            Divider()
            // Item List
            if productViewModel.products.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "basket")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 60, height: 60)
                        .foregroundColor(AppColors.accentGreen.opacity(0.7))
                    Text("You have nothing on your list!")
                        .font(.poppins(size: 18, weight: .semibold))
                        .foregroundColor(.gray)
                    HStack(spacing: 4) {
                        Text("Tap the")
                        Image(systemName: "plus.circle.fill")
                            .foregroundColor(AppColors.accentGreen)
                            .font(.system(size: 16))
                        Text("button to add your first item.")
                    }
                        .font(.poppins(size: 15, weight: .regular))
                        .foregroundColor(.gray.opacity(0.7))
                }
                .frame(maxWidth: .infinity, minHeight: 120)
                .padding(.vertical, 24)
            } else {
                List {
                    ForEach(productViewModel.products, id: \.objectID) { product in
                        ShoppingListItemRow(
                            product: product,
                            isEditing: isEditing,
                            isSelected: selectedItemsForDeletion.contains(product.id ?? ""),
                            onToggle: {
                                if isEditing {
                                    if let id = product.id {
                                        if selectedItemsForDeletion.contains(id) {
                                            selectedItemsForDeletion.remove(id)
                                        } else {
                                            selectedItemsForDeletion.insert(id)
                                        }
                                    }
                                } else {
                                    // Toggle completion status
                                    Task {
                                        await productViewModel.toggleProductCompletion(product)
                                        // Check if all products are completed after toggling
                                        // if productViewModel.allProductsCompleted {
                                        //     showingRatingPrompt = true
                                        // }
                                    }
                                }
                            },
                            onDelete: nil // Remove the onDelete callback to prevent conflicts
                        )
                        .listRowSeparator(.hidden)
                        .listRowBackground(Color.clear)
                        .listRowInsets(EdgeInsets(top: 4, leading: 0, bottom: 4, trailing: 0))
                    }
                    .onDelete(perform: deleteItems)
                }
                .listStyle(PlainListStyle())
                .background(Color.clear)
            }
            // Add Button & Check All Button
            HStack(spacing: 56) {
                Button(action: {
                    showingAddProductModal = true
                }) {
                    Image(systemName: "plus")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(.white)
                }
                .frame(width: 44, height: 44)
                .background(
                    Circle()
                        .fill(AppColors.accentGreen)
                        .shadow(color: AppColors.accentGreen.opacity(0.3), radius: 8, x: 0, y: 4)
                )
                Button(action: {
                    // Check if we're about to complete all items (not uncheck them)
                    let allCompleted = productViewModel.products.allSatisfy { $0.isCompleted }
                    if allCompleted {
                        // If all are completed, directly uncheck them all (no confirmation needed)
                        Task {
                            await productViewModel.toggleAllProductsCompletion()
                        }
                    } else {
                        // If not all are completed, show alert immediately and check items in background
                        showingCheckAllConfirmation = true
                        Task {
                            await productViewModel.toggleAllProductsCompletion()
                        }
                    }
                }) {
                    Image(systemName: "checkmark.circle")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(.white)
                }
                .frame(width: 44, height: 44)
                .background(
                    Circle()
                        .fill(AppColors.accentOrange)
                        .shadow(color: AppColors.accentOrange.opacity(0.3), radius: 8, x: 0, y: 4)
                )
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
        }
        .padding()
        .background(AppColors.backgroundPrimary)
        .cornerRadius(20)
        .shadow(color: Color.black.opacity(0.07), radius: 3, x: 0, y: 2)
        .padding(.horizontal)
    }
}
// Store Location Modal - commented out
// struct StoreLocationModal: View {
//     @Environment(\.dismiss) private var dismiss
//     @State private var searchText = ""
//     @State private var selectedStore: StoreLocation?
//     @State private var isSearchFocused = false
//     @FocusState private var isSearchFocusedState: Bool
//
//     // Sample store data - will be replaced with API data later
//     let sampleStores = [
//         StoreLocation(name: "Safeway", address: "123 Main St, Portland, OR", distance: "0.3 mi"),
//         StoreLocation(name: "Fred Meyer", address: "456 Oak Ave, Portland, OR", distance: "0.8 mi"),
//         StoreLocation(name: "Trader Joe's", address: "789 Pine St, Portland, OR", distance: "1.2 mi"),
//         StoreLocation(name: "Whole Foods Market", address: "321 Elm St, Portland, OR", distance: "1.5 mi"),
//         StoreLocation(name: "New Seasons Market", address: "654 Maple Dr, Portland, OR", distance: "2.1 mi")
//     ]
//
//     var filteredStores: [StoreLocation] {
//         if searchText.isEmpty {
//             return sampleStores
//         } else {
//             return sampleStores.filter { store in
//                 store.name.localizedCaseInsensitiveContains(searchText) ||
//                 store.address.localizedCaseInsensitiveContains(searchText)
//             }
//         }
//     }
//
//     var body: some View {
//         NavigationView {
//             VStack(spacing: 0) {
//                 // Header
//                 VStack(spacing: 16) {
//                     Text("Change Store Location")
//                         .font(.poppins(size: 24, weight: .bold))
//                         .padding(.top)
//
//                     // Search Bar
//                     HStack {
//                         Image(systemName: "magnifyingglass")
//                             .foregroundColor(.gray)
//
//                         TextField("Search stores...", text: $searchText)
//                             .font(.poppins(size: 16, weight: .regular))
//                             .focused($isSearchFocusedState)
//                             .onChange(of: isSearchFocusedState) { _, focused in
//                                 isSearchFocused = focused
//                             }
//                     }
//                     .padding()
//                     .background(Color(.systemGray6))
//                     .cornerRadius(12)
//                     .padding(.horizontal)
//                 }
//                 .padding(.bottom)
//
//                 // Store List
//                 ScrollView {
//                     LazyVStack(spacing: 12) {
//                         ForEach(filteredStores, id: \.id) { store in
//                             StoreLocationRow(
//                                 store: store,
//                                 isSelected: selectedStore?.id == store.id
//                             ) {
//                                 selectedStore = store
//                             }
//                         }
//                     }
//                     .padding(.horizontal)
//                 }
//
//                 // Select Button
//                 if let selectedStore = selectedStore {
//                     Button("Select \(selectedStore.name)") {
//                         // TODO: Update store location in app state
//                         dismiss()
//                     }
//                     .font(.poppins(size: 16, weight: .semibold))
//                     .foregroundColor(.white)
//                     .frame(maxWidth: .infinity)
//                     .padding()
//                     .background(AppColors.accentGreen)
//                     .frame(maxWidth: .infinity)
//                     .padding()
//                     .background(AppColors.accentGreen)
//                     .cornerRadius(12)
//                     .padding(.horizontal)
//                     .padding(.bottom)
//                 }
//             }
//             .navigationBarTitleDisplayMode(.inline)
//             .toolbar {
//                 ToolbarItem(placement: .navigationBarLeading) {
//                     Button("Cancel") {
//                         dismiss()
//                     }
//                     .font(.poppins(size: 16, weight: .regular))
//                     .foregroundColor(.gray)
//                 }
//             }
//         }
//     }
// }
// Store Location Row - commented out
// struct StoreLocationRow: View {
//     let store: StoreLocation
//     let isSelected: Bool
//     let onTap: () -> Void
//
//     var body: some View {
//         Button(action: onTap) {
//             HStack(spacing: 12) {
//                 // Store Icon
//                 Image(systemName: "building.2")
//                     .font(.system(size: 20))
//                     .foregroundColor(AppColors.accentGreen)
//                     .frame(width: 40, height: 40)
//                     .background(AppColors.accentGreen.opacity(0.1))
//                     .cornerRadius(8)
//
//                 // Store Info
//                 VStack(alignment: .leading, spacing: 4) {
//                     Text(store.name)
//                         .font(.poppins(size: 16, weight: .semibold))
//                         .foregroundColor(.primary)
//
//                     Text(store.address)
//                         .font(.poppins(size: 14, weight: .regular))
//                         .foregroundColor(.gray)
//                     .lineLimit(1)
//
//                     Text(store.distance)
//                         .font(.poppins(size: 12, weight: .regular))
//                         .foregroundColor(AppColors.accentGreen)
//                 }
//
//                 Spacer()
//
//                 // Selection Indicator
//                 if isSelected {
//                     Image(systemName: "checkmark.circle.fill")
//                         .font(.system(size: 20))
//                     .foregroundColor(AppColors.accentGreen)
//                 }
//             }
//             .padding()
//             .background(
//                 RoundedRectangle(cornerRadius: 12)
//                     .fill(isSelected ? AppColors.accentGreen.opacity(0.1) : Color(.systemGray6))
//                     .overlay(
//                         RoundedRectangle(cornerRadius: 12)
//                             .stroke(isSelected ? AppColors.accentGreen : Color.clear, lineWidth: 2)
//                     )
//             )
//         }
//         .buttonStyle(PlainButtonStyle())
//     }
// }
// Store Location Model - commented out
// struct StoreLocation: Identifiable {
//     let id = UUID()
//     let name: String
//     let address: String
//     let distance: String
// }
struct SmartAddProductModal: View {
    @Environment(\.dismiss) private var dismiss
    @State private var searchText = ""
    @State private var showCursor = false
    @State private var isCancelPressed = false
    @FocusState private var isSearchFocused: Bool
    @EnvironmentObject var productViewModel: ProductViewModel
    let onAdd: (String, String?, String?, Double?) -> Void
    var body: some View {
        NavigationView {
            GeometryReader { geometry in
                VStack(spacing: 0) {
                    // Fixed Header with Search
                    VStack(spacing: 16) {
                        Text("Add to Your List")
                            .font(.poppins(size: 24, weight: .bold))
                            .padding(.top)
                        // Search Bar
                        HStack {
                            Image(systemName: "magnifyingglass")
                                .foregroundColor(.gray)
                            ZStack(alignment: .leading) {
                                TextField("", text: $searchText)
                                    .font(.poppins(size: 16, weight: .regular))
                                    .focused($isSearchFocused)
                                    .onChange(of: isSearchFocused) { _, focused in
                                        if focused && searchText.isEmpty {
                                            showCursor = true
                                        } else {
                                            showCursor = false
                                        }
                                    }
                                // Placeholder text when not focused
                                if searchText.isEmpty && !isSearchFocused {
                                    Text("Search products...")
                                        .font(.poppins(size: 16, weight: .regular))
                                        .foregroundColor(.gray)
                                        .allowsHitTesting(false)
                                }
                                // Solid cursor when focused
                                if searchText.isEmpty && isSearchFocused {
                                    Rectangle()
                                        .fill(AppColors.accentGreen)
                                        .frame(width: 2, height: 20)
                                        .allowsHitTesting(false)
                                }
                            }
                        }
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
                        .padding(.horizontal)
                    }
                    .padding(.bottom)
                    .background(AppColors.backgroundSecondary)
                    // Scrollable Content Area
                    ScrollView {
                        VStack(spacing: 0) {
                            // Results Section
                            if searchText.isEmpty {
                                // Show empty state when search is empty
                                VStack(spacing: 16) {
                                    Image(systemName: "magnifyingglass")
                                        .font(.system(size: 48))
                                        .foregroundColor(.gray)
                                    Text("Search for products to add to your list")
                                        .font(.poppins(size: 18, weight: .semibold))
                                        .foregroundColor(.gray)
                                }
                                .frame(maxWidth: .infinity, minHeight: geometry.size.height * 0.4)
                                .padding(.top, 40)
                            } else {
                                // Show search results
                                SearchResultsSection(
                                    searchText: searchText,
                                    onAdd: { name, brand, category, price in
                                        onAdd(name, brand, category, price)
                                        dismiss()
                                    },
                                    onCreateNew: {
                                        // This is no longer used since we redirect to barcode scanner
                                    },
                                    dismiss: dismiss
                                )
                            }
                        }
                    }
                    .background(AppColors.backgroundSecondary)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Text("Cancel")
                        .font(.poppins(size: 16, weight: .regular))
                        .foregroundColor(isCancelPressed ? .gray.opacity(0.5) : .gray)
                        .underline()
                        .padding(.leading, 8)
                        .padding(.top, 4)
                        .onTapGesture {
                            isCancelPressed = true
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                isCancelPressed = false
                                dismiss()
                            }
                        }
                }
            }
        }
    }
}
struct SearchResultsSection: View {
    let searchText: String
    let onAdd: (String, String?, String?, Double?) -> Void
    let onCreateNew: () -> Void
    @EnvironmentObject var productViewModel: ProductViewModel
    let dismiss: DismissAction
    @State private var searchResults: [GroceryItem] = []
    @State private var isSearching = false
    @State private var showingBarcodeScanner = false
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Search Results")
                .font(.poppins(size: 18, weight: .semibold))
                .padding(.horizontal)
            if isSearching {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Searching...")
                        .font(.poppins(size: 14, weight: .regular))
                        .foregroundColor(.gray)
                }
                .padding(.horizontal)
            } else if searchResults.isEmpty {
                // No results found - redirect to barcode scanner
                VStack(spacing: 16) {
                    Image(systemName: "barcode.viewfinder")
                        .font(.system(size: 48))
                        .foregroundColor(AppColors.accentGreen)
                    Text("No products found")
                        .font(.poppins(size: 18, weight: .semibold))
                        .foregroundColor(.primary)
                    Text("Use the barcode scanner to add \"\(searchText)\" to your list")
                        .font(.poppins(size: 14, weight: .regular))
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                    Button(action: {
                        showingBarcodeScanner = true
                    }) {
                        HStack {
                            Image(systemName: "camera.fill")
                                .font(.system(size: 18))
                            Text("Open Barcode Scanner")
                                .font(.poppins(size: 16, weight: .semibold))
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(AppColors.accentGreen)
                        .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical, 20)
            } else {
                // Show search results in a scrollable container
                ScrollView {
                    LazyVStack(spacing: 8) {
                        ForEach(searchResults, id: \.objectID) { product in
                            SearchResultRow(product: product) {
                                // Add existing product to shopping list
                                Task {
                                    await productViewModel.addExistingProductToShoppingList(product)
                                }
                                dismiss()
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                .frame(maxHeight: UIScreen.main.bounds.height * 0.6) // Larger scroll area for full-screen modal
                // Divider and barcode scanner option
                Divider()
                    .padding(.horizontal)
                Button(action: {
                    showingBarcodeScanner = true
                }) {
                    HStack {
                        Image(systemName: "barcode.viewfinder")
                            .foregroundColor(AppColors.accentGreen)
                        Text("Scan barcode for \"\(searchText)\"")
                            .font(.poppins(size: 16, weight: .regular))
                            .foregroundColor(.primary)
                        Spacer()
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    .padding(.horizontal)
                }
            }
        }
        .onChange(of: searchText) { _, newValue in
            if !newValue.isEmpty {
                performSearch()
            } else {
                searchResults = []
            }
        }
        .sheet(isPresented: $showingBarcodeScanner) {
            AddItemsView(availableTags: productViewModel.tags)
        }
    }
    private func performSearch() {
        guard !searchText.isEmpty else { return }
        isSearching = true
        Task {
            // Store current products to restore them later
            let currentProducts = productViewModel.products
            // Perform search
            await productViewModel.searchProducts(by: searchText)
            await MainActor.run {
                // Store search results and restore original products
                searchResults = productViewModel.products
                productViewModel.products = currentProducts
                isSearching = false
            }
        }
    }
}
struct SearchResultRow: View {
    @ObservedObject var product: GroceryItem
    let onAdd: () -> Void
    var body: some View {
        Button(action: onAdd) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(product.productName ?? "Unknown Product")
                        .font(.poppins(size: 16, weight: .medium))
                        .foregroundColor(.primary)
                    if let brand = product.brand, !brand.isEmpty {
                        Text(brand)
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                    }
                    if let category = product.category, !category.isEmpty {
                        Text(category)
                            .font(.poppins(size: 12, weight: .regular))
                            .foregroundColor(.gray.opacity(0.7))
                    }
                }
                Spacer()
                Spacer()
                // Add button - no price display since prices vary by store
                Image(systemName: "plus.circle.fill")
                    .foregroundColor(AppColors.accentGreen)
                    .font(.system(size: 20))
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct CategoryPickerView: View {
    @Binding var selectedCategory: ProductCategory
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationView {
            List(ProductCategory.allCases, id: \.self) { category in
                Button(action: {
                    selectedCategory = category
                    dismiss()
                }) {
                    HStack {
                        Text(category.rawValue)
                            .font(.poppins(size: 16, weight: .regular))
                            .foregroundColor(category == .none ? .gray : .primary)
                        Spacer()
                        if selectedCategory == category && category != .none {
                            Image(systemName: "checkmark")
                                .foregroundColor(AppColors.accentGreen)
                        }
                    }
                }
            }
            .navigationTitle("Select Category")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
// Shopping List circle logic
struct ShoppingListItemRow: View {
    @ObservedObject var product: GroceryItem
    let isEditing: Bool
    let isSelected: Bool
    let onToggle: () -> Void
    let onDelete: (() -> Void)?
    var body: some View {
        HStack(alignment: .center) {
            Button(action: onToggle) {
                if isEditing {
                    if isSelected {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.red)
                            .font(.system(size: 20))
                    } else {
                        Image(systemName: "circle")
                            .foregroundColor(.red)
                            .font(.system(size: 20))
                    }
                } else {
                    // Show completion status
                    if product.isCompleted {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(AppColors.accentGreen)
                            .font(.system(size: 20))
                    } else {
                        Image(systemName: "circle")
                            .foregroundColor(AppColors.accentGreen)
                            .font(.system(size: 20))
                    }
                }
            }
            .buttonStyle(PlainButtonStyle())
            .frame(width: 20, height: 20)
            VStack(alignment: .leading, spacing: 2) {
                Text(product.productName ?? "Unknown Product")
                    .font(.poppins(size: 15, weight: .regular))
                    .foregroundColor(product.isCompleted ? .gray : .primary)
                    .strikethrough(product.isCompleted)
                if let brand = product.brand, !brand.isEmpty {
                    Text(brand)
                        .font(.poppins(size: 12, weight: .regular))
                        .foregroundColor(.gray)
                }
            }
            Spacer()
            // Display lowest price and store
            VStack(alignment: .trailing, spacing: 2) {
                if let lowestPrice = product.getLowestPrice(), lowestPrice.price > 0 {
                    Text("$\(String(format: "%.2f", lowestPrice.price))")
                        .font(.poppins(size: 15, weight: .semibold))
                        .foregroundColor(product.isCompleted ? .gray : AppColors.accentGreen)
                        .strikethrough(product.isCompleted)
                    if let store = lowestPrice.store, !store.isEmpty {
                        Text(store)
                            .font(.poppins(size: 10, weight: .regular))
                            .foregroundColor(.gray)
                    }
                    // Display update information
                    if let updatedBy = lowestPrice.updatedBy, !updatedBy.isEmpty {
                        Text("Updated by \(updatedBy)")
                            .font(.poppins(size: 8, weight: .regular))
                            .foregroundColor(.gray.opacity(0.6))
                    }
                    if let lastUpdated = lowestPrice.lastUpdated {
                        Text(formatDate(lastUpdated))
                            .font(.poppins(size: 8, weight: .regular))
                            .foregroundColor(.gray.opacity(0.6))
                    }
                } else {
                    Text("No price")
                        .font(.poppins(size: 12, weight: .regular))
                        .foregroundColor(.gray.opacity(0.7))
                }
            }
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 12)
        .background(
            RoundedRectangle(cornerRadius: 14)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.07), radius: 3, x: 0, y: 2)
        )
        .contentShape(Rectangle()) // Ensure the entire row is tappable
        .padding(.horizontal, 2)
    }
}
// Helper function to format dates
private func formatDate(_ date: Date) -> String {
    let formatter = DateFormatter()
    let now = Date()
    let calendar = Calendar.current

    if calendar.isDateInToday(date) {
        formatter.timeStyle = .short
        return "Today \(formatter.string(from: date))"
    } else if calendar.isDateInYesterday(date) {
        formatter.timeStyle = .short
        return "Yesterday \(formatter.string(from: date))"
    } else if calendar.dateInterval(of: .weekOfYear, for: now)?.contains(date) == true {
        formatter.dateFormat = "EEEE"
        return formatter.string(from: date)
    } else {
        formatter.dateStyle = .short
        return formatter.string(from: date)
    }
}
// Rating Prompt View
struct RatingPromptView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var showRatingScreen = false
    var body: some View {
        VStack(spacing: 24) {
            // Header
            VStack(spacing: 12) {
                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 48))
                    .foregroundColor(AppColors.accentGreen)
                Text("Have you finished shopping?")
                    .font(.poppins(size: 24, weight: .bold))
                    .foregroundColor(.primary)
                Text("Rate your experience")
                    .font(.poppins(size: 16, weight: .regular))
                    .foregroundColor(.gray)
            }
            .padding(.top, 40)
            Spacer()
            // Action Buttons
            VStack(spacing: 12) {
                Button(action: {
                    showRatingScreen = true
                }) {
                    Text("Rate my experience")
                        .font(.poppins(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(AppColors.accentGreen)
                        .cornerRadius(12)
                        .contentShape(Rectangle())
                }
                Button(action: {
                    dismiss()
                }) {
                    Text("No thanks")
                        .font(.poppins(size: 16, weight: .regular))
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(12)
                        .contentShape(Rectangle())
                }
            }
            .padding(.horizontal, 24)
            .padding(.bottom, 40)
        }
        .background(AppColors.backgroundSecondary)
        .sheet(isPresented: $showRatingScreen) {
            ShoppingExperienceRatingView(dismissAll: {
                dismiss()
                showRatingScreen = false
            })
        }
    }
}
// Shopping Experience Rating View
struct ShoppingExperienceRatingView: View {
    var dismissAll: () -> Void
    @State private var pricingRating: Int = 0
    @State private var overallRating: Int = 0
    var body: some View {
        VStack(spacing: 32) {
            Text("Rate your shopping Experience!")
                .font(.poppins(size: 28, weight: .bold))
                .multilineTextAlignment(.center)
                .padding(.top, 32)
            VStack(alignment: .leading, spacing: 12) {
                Text("Grocery Store")
                    .font(.poppins(size: 20, weight: .bold))
                // TODO: Connect to Google Maps API for live store info
                HStack {
                    Image(systemName: "mappin.and.ellipse")
                        .foregroundColor(AppColors.accentGreen)
                    Text("Whole Foods Market")
                        .font(.poppins(size: 17, weight: .semibold))
                    Spacer()
                    Text("1701 Wewatta St.")
                        .font(.poppins(size: 15, weight: .regular))
                        .foregroundColor(.gray)
                }
                .padding(12)
                .background(Color.gray.opacity(0.10))
                .cornerRadius(16)
            }
            .padding(.horizontal, 16)
            VStack(alignment: .leading, spacing: 8) {
                Text("Pricing Accuracy")
                    .font(.poppins(size: 20, weight: .bold))
                StarRatingView(rating: $pricingRating, accentColor: AppColors.accentGreen)
            }
            .padding(.horizontal, 16)
            VStack(alignment: .leading, spacing: 8) {
                Text("Overall Experience")
                    .font(.poppins(size: 20, weight: .bold))
                StarRatingView(rating: $overallRating, accentColor: AppColors.accentGreen)
            }
            .padding(.horizontal, 16)
            Spacer()
            // Action Buttons
            VStack(spacing: 12) {
                Button(action: {
                    // TODO: Handle submit logic
                    dismissAll()
                }) {
                    Text("Submit")
                        .font(.poppins(size: 16, weight: .semibold))
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(AppColors.accentGreen)
                        .cornerRadius(12)
                        .contentShape(Rectangle())
                }
                Button(action: {
                    dismissAll()
                }) {
                    Text("Cancel")
                        .font(.poppins(size: 16, weight: .regular))
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity)
                        .frame(height: 50)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(12)
                        .contentShape(Rectangle())
                }
            }
            .padding(.horizontal, 24)
            .padding(.bottom, 40)
        }
        .background(AppColors.backgroundSecondary)
        .cornerRadius(24)
        .padding(8)
    }
}
// Star Rating View
struct StarRatingView: View {
    @Binding var rating: Int
    var accentColor: Color = .yellow
    let maxRating = 5
    var body: some View {
        HStack(spacing: 16) {
            ForEach(1...maxRating, id: \.self) { index in
                Image(systemName: rating >= index ? "star.fill" : "star")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 36, height: 36)
                    .foregroundColor(accentColor)
                    .onTapGesture {
                        rating = index
                    }
            }
        }
    }
}
// struct RecentProductRow: View {
//     let product: GroceryItem
//     let onAdd: () -> Void
//
//     var body: some View {
//         Button(action: onAdd) {
//             HStack {
//                 VStack(alignment: .leading, spacing: 4) {
//                     Text(product.productName ?? "Unknown Product")
//                         .font(.poppins(size: 16, weight: .medium))
//                         .foregroundColor(.primary)
//
//                     if let brand = product.brand, !brand.isEmpty {
//                         Text(brand)
//                             .font(.poppins(size: 14, weight: .regular))
//                             .foregroundColor(.gray)
//                     }
//
//                     if let category = product.category, !category.isEmpty {
//                         Text(category)
//                             .font(.poppins(size: 12, weight: .regular))
//                             .foregroundColor(.gray.opacity(0.7))
//                     }
//                 }
//
//                 Spacer()
//
//                 Image(systemName: "plus.circle.fill")
//                     .foregroundColor(AppColors.accentGreen)
//                     .font(.system(size: 20))
//             }
//             .padding()
//             .background(Color(.systemGray6))
//             .cornerRadius(12)
//         }
//         .buttonStyle(PlainButtonStyle())
//     }
// }
// Amazon Price Results View
struct AmazonPriceResultsView: View {
    let results: [GroceryItem]
    let onSelectPrice: (Double) -> Void
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                VStack(spacing: 16) {
                    Text("Amazon Price Results")
                        .font(.poppins(size: 24, weight: .bold))
                        .padding(.top)
                    Text("Select a price from Amazon")
                        .font(.poppins(size: 16, weight: .regular))
                        .foregroundColor(.gray)
                }
                .padding(.bottom)
                // Results List
                if results.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 48))
                            .foregroundColor(.gray)
                        Text("No price results found")
                            .font(.poppins(size: 18, weight: .semibold))
                            .foregroundColor(.gray)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(results, id: \.objectID) { product in
                                AmazonPriceResultRow(
                                    product: product,
                                    onSelect: {
                                        onSelectPrice(product.price)
                                    }
                                )
                            }
                        }
                        .padding(.horizontal)
                    }
                }
                Spacer()
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .font(.poppins(size: 16, weight: .regular))
                    .foregroundColor(.gray)
                }
            }
        }
    }
}
// Amazon Price Result Row
struct AmazonPriceResultRow: View {
    @ObservedObject var product: GroceryItem
    let onSelect: () -> Void
    var body: some View {
        Button(action: onSelect) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(product.productName ?? "Unknown Product")
                        .font(.poppins(size: 16, weight: .medium))
                        .foregroundColor(.primary)
                    if let brand = product.brand, !brand.isEmpty {
                        Text(brand)
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                    }
                    if let store = product.store, !store.isEmpty {
                        Text(store)
                            .font(.poppins(size: 12, weight: .regular))
                            .foregroundColor(.gray.opacity(0.7))
                    }
                }
                Spacer()
                // Price display - always on the right
                HStack(spacing: 8) {
                    if product.price > 0 {
                        Text("$\(String(format: "%.2f", product.price))")
                            .font(.poppins(size: 16, weight: .semibold))
                            .foregroundColor(AppColors.accentGreen)
                            .frame(minWidth: 60, alignment: .trailing)
                    } else {
                        // Empty space to maintain alignment
                        Text("")
                            .font(.poppins(size: 16, weight: .semibold))
                            .frame(minWidth: 60, alignment: .trailing)
                    }
                    Image(systemName: "chevron.right")
                        .font(.system(size: 14))
                        .foregroundColor(.gray)
                }
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
#Preview {
    YourListView()
}
//
//  ProductImageView.swift
//  CartWise
//
//  Created by Kelly Yong on 8/4/25.
//  Enhanced with AI assistance from Cursor AI for UI improvements and functionality.
//

import SwiftUI
import UIKit

struct ProductImageView: View {
    @ObservedObject var product: GroceryItem
    let size: CGSize
    let cornerRadius: CGFloat
    let showSaleBadge: Bool
    @State private var loadedImage: UIImage?
    @State private var isLoading = false
    @State private var hasError = false

    init(
        product: GroceryItem,
        size: CGSize = CGSize(width: 180, height: 180),
        cornerRadius: CGFloat = 12,
        showSaleBadge: Bool = true
    ) {
        self.product = product
        self.size = size
        self.cornerRadius = cornerRadius
        self.showSaleBadge = showSaleBadge
    }

    var body: some View {
        Group {
            if let productImage = product.productImage {
                if let imageData = productImage.imageData, let uiImage = UIImage(data: imageData) {
                    // Display cached image data
                    Image(uiImage: uiImage)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: size.width, height: size.height)
                        .cornerRadius(cornerRadius)
                        .overlay(saleBadgeOverlay)
                } else if let imageURL = productImage.imageURL, !imageURL.isEmpty {
                    // Fallback to loading from URL if no cached data
                    if let loadedImage = loadedImage {
                        // Display loaded image
                        Image(uiImage: loadedImage)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(width: size.width, height: size.height)
                            .cornerRadius(cornerRadius)
                            .overlay(saleBadgeOverlay)
                    } else if isLoading {
                        loadingView
                    } else if hasError {
                        failureView
                    } else {
                        // Start loading
                        loadingView
                            .onAppear {
                                loadImageFromURL(imageURL)
                            }
                    }
                } else {
                    noImagePlaceholder
                }
            } else {
                noImagePlaceholder
            }
        }
        .onChange(of: product.productImage?.imageURL) { newURL in
            if let newURL = newURL, !newURL.isEmpty {
                loadImageFromURL(newURL)
            }
        }
    }

    private func loadImageFromURL(_ urlString: String) {
        guard let url = URL(string: urlString) else {
            hasError = true
            return
        }

        isLoading = true
        hasError = false

        Task {
            do {
                let (data, _) = try await URLSession.shared.data(from: url)
                if let image = UIImage(data: data) {
                    await MainActor.run {
                        self.loadedImage = image
                        self.isLoading = false
                    }
                } else {
                    await MainActor.run {
                        self.hasError = true
                        self.isLoading = false
                    }
                }
            } catch {
                await MainActor.run {
                    self.hasError = true
                    self.isLoading = false
                }
            }
        }
    }

    // MARK: - View Components

    private var loadingView: some View {
        RoundedRectangle(cornerRadius: cornerRadius)
            .fill(Color(.systemGray5))
            .frame(width: size.width, height: size.height)
            .overlay(
                VStack {
                    ProgressView()
                        .scaleEffect(1.2)
                    Text("Loading image...")
                        .font(.system(size: 14))
                        .foregroundColor(.gray)
                        .padding(.top, 8)
                }
            )
            .overlay(saleBadgeOverlay)
    }

    private var failureView: some View {
        RoundedRectangle(cornerRadius: cornerRadius)
            .fill(Color(.systemGray5))
            .frame(width: size.width, height: size.height)
            .overlay(
                VStack(spacing: 4) {
                    Image(systemName: "photo")
                        .foregroundColor(.gray)
                        .font(.system(size: min(size.width, size.height) * 0.3))
                    Text("Image unavailable")
                        .font(.system(size: min(size.width, size.height) * 0.08))
                        .foregroundColor(.gray)
                        .lineLimit(2)
                        .multilineTextAlignment(.center)
                }
                .padding(.horizontal, 8)
            )
            .overlay(saleBadgeOverlay)
    }

    private var noImagePlaceholder: some View {
        RoundedRectangle(cornerRadius: cornerRadius)
            .fill(Color(.systemGray5))
            .frame(width: size.width, height: size.height)
            .overlay(
                VStack(spacing: 4) {
                    Image(systemName: "photo")
                        .foregroundColor(.gray)
                        .font(.system(size: min(size.width, size.height) * 0.3))
                    Text("No image available")
                        .font(.system(size: min(size.width, size.height) * 0.08))
                        .foregroundColor(.gray)
                        .lineLimit(2)
                        .multilineTextAlignment(.center)
                }
                .padding(.horizontal, 8)
            )
            .overlay(saleBadgeOverlay)
    }

    private var saleBadgeOverlay: some View {
        VStack {
            if product.isOnSale && showSaleBadge {
                Text("Sale")
                    .font(.system(size: 14, weight: .bold))
                    .frame(width: 100, height: 24)
                    .foregroundColor(.white)
                    .background(Color.accentColorOrange.opacity(0.9))
                    .cornerRadius(8)
            }
            Spacer()
        }
        .padding(.top, 12)
    }
}
//
//  MyProfileView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//
import SwiftUI
import CoreData
struct MyProfileView: View {
    @AppStorage("isLoggedIn") private var isLoggedIn: Bool = false
    @EnvironmentObject var productViewModel: ProductViewModel
    @State private var currentUsername: String = ""
    @State private var isLoadingUser: Bool = true
    @State private var showAddLocation: Bool = false
    @State private var selectedTab: ProfileTab = .favorites

    enum ProfileTab: String, CaseIterable {
        case favorites = "Favorites"
        case locations = "Locations"
        case reputation = "Reputation"
    }

    var body: some View {
        NavigationView {
            ZStack {
                // Background
                AppColors.backgroundSecondary
                    .ignoresSafeArea()

                ScrollView {
                    VStack(spacing: 24) {
                        // Profile Card
                        ProfileCard(
                            currentUsername: currentUsername,
                            isLoadingUser: isLoadingUser
                        )

                        // Tabbed Content
                        TabbedContentView(selectedTab: $selectedTab)

                        // Logout Button
                        LogoutButton(action: {
                            withAnimation(.easeInOut(duration: 0.2)) {
                                // Clear the current username when logging out
                                UserDefaults.standard.removeObject(forKey: "currentUsername")
                                isLoggedIn = false
                            }
                        })
                        .padding(.horizontal)
                        .padding(.bottom, 32)
                    }
                    .padding(.top, 16)
                }
            }
            .navigationTitle("Profile")
            .navigationBarTitleDisplayMode(.inline)
            .task {
                await loadCurrentUser()
            }
            .sheet(isPresented: $showAddLocation) {
                AddLocationView()
                    .environmentObject(productViewModel)
            }
        }
    }
    private func loadCurrentUser() async {
        isLoadingUser = true
        do {
            let context = PersistenceController.shared.container.viewContext
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            // Since we don't have a direct way to identify the current user,
            // we'll fetch the most recently created user (assuming the last logged in user)
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try context.fetch(fetchRequest)
            if let currentUser = users.first, let username = currentUser.username {
                await MainActor.run {
                    withAnimation(.easeInOut(duration: 0.3)) {
                        currentUsername = username
                        isLoadingUser = false
                    }
                }
            } else {
                await MainActor.run {
                    withAnimation(.easeInOut(duration: 0.3)) {
                        currentUsername = "User"
                        isLoadingUser = false
                    }
                }
            }
        } catch {
            print("Error loading current user: \(error)")
            await MainActor.run {
                withAnimation(.easeInOut(duration: 0.3)) {
                    currentUsername = "User"
                    isLoadingUser = false
                }
            }
        }
    }
}

// MARK: - Tabbed Content View
struct TabbedContentView: View {
    @Binding var selectedTab: MyProfileView.ProfileTab

    var body: some View {
        VStack(spacing: 0) {
            // Tab Selector
            TabSelector(selectedTab: $selectedTab)

            // Tab Content
            VStack(spacing: 0) {
                if selectedTab == .favorites {
                    FavoriteItemsView()
                        .transition(.opacity)
                } else if selectedTab == .locations {
                    LocationsSectionView()
                        .transition(.opacity)
                } else if selectedTab == .reputation {
                    ReputationTabView()
                        .transition(.opacity)
                }
            }
            .animation(.easeInOut(duration: 0.2), value: selectedTab)
        }
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.06), radius: 8, x: 0, y: 4)
        )
        .padding(.horizontal)
    }
}

// MARK: - Tab Selector
struct TabSelector: View {
    @Binding var selectedTab: MyProfileView.ProfileTab

    var body: some View {
        HStack(spacing: 0) {
            ForEach(MyProfileView.ProfileTab.allCases, id: \.self) { tab in
                Button(action: {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        selectedTab = tab
                    }
                }) {
                    VStack(spacing: 8) {
                        Text(tab.rawValue)
                            .font(.poppins(size: 16, weight: selectedTab == tab ? .semibold : .medium))
                            .foregroundColor(selectedTab == tab ? AppColors.accentGreen : .gray)

                        // Underline indicator
                        Rectangle()
                            .fill(selectedTab == tab ? AppColors.accentGreen : Color.clear)
                            .frame(height: 2)
                            .cornerRadius(1)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding(.horizontal, 20)
        .padding(.top, 16)
    }
}

// MARK: - Profile Card Component
struct ProfileCard: View {
    let currentUsername: String
    let isLoadingUser: Bool

    var body: some View {
        VStack(spacing: 20) {
            // Profile Avatar
            ZStack {
                Circle()
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                AppColors.accentGreen.opacity(0.15),
                                AppColors.accentGreen.opacity(0.05)
                            ]),
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 80, height: 80)

                Image(systemName: "person.crop.circle.fill")
                    .resizable()
                    .frame(width: 64, height: 64)
                    .foregroundColor(AppColors.accentGreen)
            }
            .padding(.top, 16)

            // User Info
            VStack(spacing: 8) {
                if isLoadingUser {
                    ProgressView()
                        .scaleEffect(0.8)
                        .padding(.vertical, 8)
                } else {
                    Text(currentUsername.isEmpty ? "User" : currentUsername)
                        .font(.poppins(size: 24, weight: .bold))
                        .foregroundColor(AppColors.textPrimary)
                }

                Text("Manage your account and preferences")
                    .font(.poppins(size: 14, weight: .regular))
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 20)
            }
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.06), radius: 8, x: 0, y: 4)
        )
        .padding(.horizontal)
    }
}

// MARK: - Logout Button Component
struct LogoutButton: View {
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                Image(systemName: "rectangle.portrait.and.arrow.right")
                    .font(.system(size: 16, weight: .medium))
                Text("Log Out")
                    .font(.poppins(size: 16, weight: .semibold))
            }
            .foregroundColor(.white)
            .frame(maxWidth: .infinity)
            .frame(height: 50)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(
                        LinearGradient(
                            gradient: Gradient(colors: [
                                AppColors.accentRed,
                                AppColors.accentRed.opacity(0.8)
                            ]),
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .shadow(color: AppColors.accentRed.opacity(0.25), radius: 8, x: 0, y: 4)
            )
        }
        .scaleEffect(1.0)
        .animation(.easeInOut(duration: 0.2), value: true)
    }
}

// MARK: - Reputation Tab View
struct ReputationTabView: View {
    @State private var userUpdates: Int = 0
    @State private var userLevel: String = "New Shopper"
    @State private var isLoading: Bool = true

    var body: some View {
        VStack(spacing: 20) {
            if isLoading {
                VStack(spacing: 16) {
                    ProgressView()
                        .scaleEffect(1.2)

                    Text("Loading reputation data...")
                        .font(.poppins(size: 14, weight: .medium))
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                ReputationCardView(updates: userUpdates, level: userLevel)
                    .padding(.horizontal)
            }
        }
        .padding(.vertical, 20)
        .task {
            await loadUserReputation()
        }
        .onAppear {
            Task {
                await loadUserReputation()
            }
        }
    }

    private func loadUserReputation() async {
        if let reputation = await ReputationManager.shared.getCurrentUserReputation() {
            await MainActor.run {
                userUpdates = reputation.updates
                userLevel = reputation.level
                isLoading = false
            }
        } else {
            await MainActor.run {
                userUpdates = 0
                userLevel = "New Shopper"
                isLoading = false
            }
        }
    }
}
//
//  AddItemsView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//
import SwiftUI
import CoreData
struct AddItemsView: View {
    @StateObject private var productViewModel = ProductViewModel(repository: ProductRepository())
    let availableTags: [Tag] // Pass tags as parameter
    @State private var showingCamera = false
    @State private var showingSuccess = false
    @State private var showingError = false
    @State private var isProcessing = false
    @State private var scannedBarcode = ""
    @State private var errorMessage = ""
    @State private var successMessage = ""
    // Barcode confirmation state
    @State private var showingBarcodeConfirmation = false
    @State private var pendingBarcode: String = ""
    @State private var pendingProductName: String = ""
    @State private var pendingCompany: String = ""
    @State private var pendingPrice: String = ""
    @State private var pendingCategory: ProductCategory = .none
    @State private var pendingIsOnSale: Bool = false
    @State private var showCategoryPicker = false
    @State private var pendingLocation: Location? = nil
    @State private var showLocationPicker = false
    @State private var selectedTags: [Tag] = []
    @State private var showingTagPicker = false
    @State private var addToShoppingList = false
    @State private var isExistingProduct = false
    @State private var isScanInProgress = false

    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Spacer()
                // Camera View
                if showingCamera {
                    ZStack {
                        CameraView(
                            onBarcodeScanned: { barcode in
                                handleBarcodeScanned(barcode)
                            },
                            onError: { error in
                                handleError(error)
                            }
                        )
                        .cornerRadius(12)
                        .padding(.horizontal)
                        // Overlay for camera instructions
                        VStack {
                            Spacer()
                            Text("Position barcode within the frame")
                                .font(.caption)
                                .foregroundColor(.white)
                                .padding(.horizontal, 16)
                                .padding(.vertical, 8)
                                .background(Color.black.opacity(0.6))
                                .cornerRadius(8)
                                .padding(.bottom, 40)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    // Placeholder when camera is not showing
                    RoundedRectangle(cornerRadius: 12)
                        .fill(AppColors.backgroundSecondary)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .overlay(
                            VStack(spacing: 12) {
                                Image(systemName: "barcode.viewfinder")
                                    .font(.system(size: 60))
                                    .foregroundColor(AppColors.accentGreen)
                                Text("Scan a barcode to add or edit it")
                                    .font(.body)
                                    .foregroundColor(AppColors.textPrimary.opacity(0.7))
                                    .multilineTextAlignment(.center)
                            }
                        )
                        .padding(.top, 40)
                        .padding(.horizontal)
                }
                // Action Buttons
                VStack(spacing: 12) {
                    // Scan Button
                    Button(action: {
                        showingCamera.toggle()
                    }) {
                        HStack {
                            Image(systemName: showingCamera ? "stop.fill" : "camera.fill")
                                .font(.system(size: 18))
                            Text(showingCamera ? "Stop Scanning" : "Start Scanning")
                                .fontWeight(.semibold)
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(AppColors.accentGreen)
                        .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
                // Processing Indicator
                if isProcessing {
                    VStack(spacing: 8) {
                        ProgressView()
                            .scaleEffect(1.2)
                        Text("Processing barcode...")
                            .font(.caption)
                            .foregroundColor(AppColors.textPrimary.opacity(0.7))
                    }
                    .padding(.horizontal)
                }
                // Success Message
                if showingSuccess {
                    VStack(spacing: 8) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(AppColors.accentGreen)
                        Text(successMessage)
                            .font(.caption)
                            .foregroundColor(AppColors.accentGreen)
                    }
                    .padding(.horizontal)
                }
                // Scanned Result
                if !scannedBarcode.isEmpty && !isProcessing {
                    VStack(spacing: 8) {
                        Text("Scanned Barcode: ")
                            .font(.caption)
                            .foregroundColor(AppColors.textPrimary.opacity(0.7))
                        Text(scannedBarcode)
                            .font(.system(.body, design: .monospaced))
                            .foregroundColor(AppColors.textPrimary)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 8)
                            .background(AppColors.backgroundSecondary)
                            .cornerRadius(8)
                    }
                    .padding(.horizontal)
                }
                Spacer()
            }
            .navigationTitle("Add Items")
            .navigationBarTitleDisplayMode(.large)
            .onAppear {
                // Tags are now passed as parameter, no need to fetch
            }
                                        .fullScreenCover(isPresented: $showingBarcodeConfirmation) {
                BarcodeConfirmationView(
                    barcode: $pendingBarcode,
                    productName: $pendingProductName,
                    company: $pendingCompany,
                    price: $pendingPrice,
                    selectedCategory: $pendingCategory,
                    isOnSale: $pendingIsOnSale,
                    selectedLocation: $pendingLocation,
                    showLocationPicker: $showLocationPicker,
                    showCategoryPicker: $showCategoryPicker,
                    availableTags: availableTags,
                    selectedTags: $selectedTags,
                    showingTagPicker: $showingTagPicker,
                    addToShoppingList: $addToShoppingList,
                    isExistingProduct: $isExistingProduct,
                    isScanInProgress: isScanInProgress,
                    onConfirm: { barcode, productName, company, price, category, isOnSale, location, tags, addToShoppingList in
                        showingBarcodeConfirmation = false
                        isScanInProgress = false
                        Task {
                            await handleBarcodeProcessing(barcode: barcode, productName: productName, company: company, price: price, category: category, isOnSale: isOnSale, location: location, tags: tags, addToShoppingList: addToShoppingList)
                        }
                    },
                    onCancel: {
                        showingBarcodeConfirmation = false
                        resetPendingData()
                        isScanInProgress = false
                    }
                )
                .id("BarcodeConfirmation-\(isExistingProduct)")
                .sheet(isPresented: $showCategoryPicker) {
                    CategoryPickerView(selectedCategory: $pendingCategory)
                }
                .sheet(isPresented: $showingTagPicker) {
                    TagPickerView(
                        allTags: availableTags,
                        selectedTags: $selectedTags,
                        onDone: { showingTagPicker = false }
                    )
                }
                .sheet(isPresented: $showLocationPicker) {
                    LocationPickerView(selectedLocation: $pendingLocation)
                }
            }
            .alert("Error", isPresented: $showingError) {
                Button("OK") {
                    showingError = false
                    errorMessage = ""
                }
            } message: {
                Text(errorMessage.isEmpty ? "An unknown error occurred" : errorMessage)
            }
        }
    }
    private func handleBarcodeScanned(_ barcode: String) {
        // Set scan in progress to disable button
        isScanInProgress = true

        // Reset all pending data first to ensure clean state
        resetPendingData()
        pendingBarcode = barcode
        showingCamera = false

        // Check if product already exists and fetch its data
        Task {
            do {
                let existingProducts = try await productViewModel.searchProductsByBarcode(barcode)
                await MainActor.run {
                    if let existingProduct = existingProducts.first {
                        // Auto-fill with existing data
                        isExistingProduct = true
                        pendingProductName = existingProduct.productName ?? ""
                        pendingCompany = existingProduct.brand ?? ""
                        pendingCategory = ProductCategory(rawValue: existingProduct.category ?? "") ?? .none
                        pendingIsOnSale = existingProduct.isOnSale

                        // Get the most recent price and location
                        if let prices = existingProduct.prices as? Set<GroceryItemPrice>,
                           let mostRecentPrice = prices.max(by: { ($0.lastUpdated ?? Date.distantPast) < ($1.lastUpdated ?? Date.distantPast) }) {
                            pendingPrice = String(format: "%.2f", mostRecentPrice.price)
                            pendingLocation = mostRecentPrice.location
                        }

                        // Load existing tags
                        if let existingTags = existingProduct.tags as? Set<Tag> {
                            selectedTags = Array(existingTags)
                        } else {
                            selectedTags = []
                        }

                    } else {
                        isExistingProduct = false
                        // Keep fields empty for new product
                    }
                    // Reset scan in progress after data is loaded
                    isScanInProgress = false
                    // Small delay to ensure state is set before showing sheet
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        showingBarcodeConfirmation = true
                    }
                }
            } catch {
                await MainActor.run {
                    isExistingProduct = false
                    // Reset scan in progress after error
                    isScanInProgress = false
                    // Small delay to ensure state is set before showing sheet
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        showingBarcodeConfirmation = true
                    }
                }
            }
        }
    }
    private func handleBarcodeProcessing(barcode: String, productName: String, company: String, price: String, category: ProductCategory, isOnSale: Bool, location: Location?, tags: [Tag], addToShoppingList: Bool) async {
        scannedBarcode = barcode
        isProcessing = true
        Task {
            // Convert price string to Double
            let priceValue = Double(price.replacingOccurrences(of: "$", with: "")) ?? 0.0
            // Get store name from location or use a default
            let storeName = location?.name ?? "Unknown Store"
            // Check if product already exists before processing
            let wasExistingProduct = await productViewModel.isDuplicateBarcode(barcode)
            // Use ViewModel to create or update product
            let newProduct = await createOrUpdateProductByBarcode(
                barcode: barcode,
                productName: productName.isEmpty ? "Unknown Product" : productName,
                brand: company.isEmpty ? nil : company,
                category: category == .none ? nil : category.rawValue,
                price: priceValue,
                store: storeName,
                isOnSale: isOnSale
            )
            // Associate tags with the new product
            if let newProduct = newProduct {
                // For existing products, replace tags instead of adding to them
                if wasExistingProduct {
                    await productViewModel.replaceTagsForProduct(newProduct, tags: tags)
                } else {
                    await productViewModel.addTagsToProduct(newProduct, tags: tags)
                }

                // Add to shopping list if requested
                if addToShoppingList {
                    await productViewModel.addExistingProductToShoppingList(newProduct)
                }
                // Refresh price comparison after adding product
                await productViewModel.loadLocalPriceComparison()
                // Create social feed entry for new product with price
                if priceValue > 0 {
                    await createSocialFeedEntryForProduct(product: newProduct, price: priceValue, location: location, isNewProduct: !wasExistingProduct)
                }

                // Note: Reputation is updated in CoreDataContainer.createProduct() and updateProductWithPrice()
                // No need to update here to avoid double incrementing
            }
            await MainActor.run {
                isProcessing = false
                if let error = productViewModel.errorMessage {
                    errorMessage = error
                    showingError = true
                } else {
                    // Success - show success message and clear the scanned barcode
                    let shoppingListText = addToShoppingList ? " and added to shopping list" : ""
                    successMessage = wasExistingProduct ? "Product updated successfully!\(shoppingListText)" : "Product added successfully!\(shoppingListText)"
                    showingSuccess = true
                    scannedBarcode = ""
                    // Hide success message after 2 seconds
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        showingSuccess = false
                    }
                }
            }
        }
    }

    private func createOrUpdateProductByBarcode(barcode: String, productName: String, brand: String?, category: String?, price: Double, store: String, isOnSale: Bool) async -> GroceryItem? {
        // First check if product already exists with this barcode
        if await productViewModel.isDuplicateBarcode(barcode) {
            // Product exists, update it
            if let updatedProduct = await productViewModel.updateProductByBarcode(
                barcode: barcode,
                productName: productName,
                brand: brand,
                category: category,
                price: price,
                store: store,
                isOnSale: isOnSale
            ) {
                return updatedProduct
            }
        } else {
            // Product doesn't exist, create new product
            return await productViewModel.createProductByBarcode(
                barcode: barcode,
                productName: productName,
                brand: brand,
                category: category,
                price: price,
                store: store,
                isOnSale: isOnSale
            )
        }
        return nil
    }

    private func createSocialFeedEntryForProduct(product: GroceryItem, price: Double, location: Location?, isNewProduct: Bool) async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Get the product in the current context
            let productFetchRequest: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            productFetchRequest.predicate = NSPredicate(format: "id == %@", product.id ?? "")
            productFetchRequest.fetchLimit = 1
            let products = try context.fetch(productFetchRequest)
            guard let productInContext = products.first else {
                print("Error: Could not find product in context for social feed")
                return
            }
            // Get location in the current context
            let locationInContext: Location?
            if let location = location {
                let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
                locationFetchRequest.predicate = NSPredicate(format: "id == %@", location.id ?? "")
                locationFetchRequest.fetchLimit = 1
                let locations = try context.fetch(locationFetchRequest)
                locationInContext = locations.first
            } else {
                locationInContext = nil
            }
            // Get current user in the same context
            let currentUsername = UserDefaults.standard.string(forKey: "currentUsername") ?? "Unknown User"
            let userFetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            userFetchRequest.predicate = NSPredicate(format: "username == %@", currentUsername)
            userFetchRequest.fetchLimit = 1
            let users = try context.fetch(userFetchRequest)
            guard let currentUser = users.first else {
                print("Error: Could not find user in context for social feed")
                return
            }
            // Create enhanced comment with all required information
            let storeName = locationInContext?.name ?? "Unknown Store"
            let productName = productInContext.productName ?? "Unknown Product"
            let formattedPrice = String(format: "%.2f", price)
            // Format address
            var addressComponents: [String] = []
            if let address = locationInContext?.address, !address.isEmpty {
                addressComponents.append(address)
            }
            if let city = locationInContext?.city, !city.isEmpty {
                addressComponents.append(city)
            }
            if let state = locationInContext?.state, !state.isEmpty {
                addressComponents.append(state)
            }
            if let zipCode = locationInContext?.zipCode, !zipCode.isEmpty {
                addressComponents.append(zipCode)
            }
            let addressString = addressComponents.isEmpty ? "" : " (\(addressComponents.joined(separator: ", ")))"
            let comment: String
            if isNewProduct {
                comment = "New product added: \(productName) is $\(formattedPrice) at \(storeName)\(addressString)"
            } else {
                comment = "Price updated for \(productName) at \(storeName)\(addressString): $\(formattedPrice)"
            }
            // Create the social experience
            let experience = ShoppingExperience(
                context: context,
                id: UUID().uuidString,
                comment: comment,
                rating: 0,
                type: isNewProduct ? "new_product" : "price_update",
                user: currentUser,
                groceryItem: productInContext,
                location: locationInContext
            )
            try context.save()
            print("Successfully created social feed entry for product: \(productName) at \(storeName)")
        } catch {
            print("Error creating social feed entry for product: \(error)")
        }
    }
    private func resetPendingData() {
        pendingBarcode = ""
        pendingProductName = ""
        pendingCompany = ""
        pendingPrice = ""
        pendingCategory = .none
        pendingIsOnSale = false
        pendingLocation = nil
        selectedTags = []
        addToShoppingList = false
        isExistingProduct = false
    }
    private func handleError(_ error: String) {
        errorMessage = error
        showingError = true
        showingCamera = false
    }
}
// MARK: - Tag Picker View
struct TagPickerView: View {
    let allTags: [Tag]
    @Binding var selectedTags: [Tag]
    let onDone: () -> Void
    @State private var searchText = ""
    @State private var localSelectedTags: [Tag] = []

    var filteredTags: [Tag] {
        if searchText.isEmpty {
            return allTags
        } else {
            return allTags.filter { tag in
                tag.displayName.localizedCaseInsensitiveContains(searchText)
            }
        }
    }

    var body: some View {
        NavigationView {
            VStack {
                // Search bar
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField("Search tags...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                .padding(.horizontal)
                .padding(.top)
                List {
                    ForEach(filteredTags, id: \.id) { tag in
                        Button(action: {
                            if localSelectedTags.contains(where: { $0.id == tag.id }) {
                                localSelectedTags.removeAll { $0.id == tag.id }
                            } else {
                                localSelectedTags.append(tag)
                            }
                        }) {
                            HStack {
                                Text(tag.displayName)
                                Spacer()
                                if localSelectedTags.contains(where: { $0.id == tag.id }) {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.accentColor)
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Select Tags")
            .navigationBarItems(trailing: Button("Done") {
                selectedTags = localSelectedTags
                onDone()
            })
            .onAppear {
                // Initialize local selection with current selected tags
                localSelectedTags = selectedTags
            }
        }
    }
}
// MARK: - Tag Chip View
struct TagChipView: View {
    let tag: Tag
    let onRemove: () -> Void
    var body: some View {
        HStack {
            Text(tag.displayName)
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color(hex: tag.displayColor))
                .foregroundColor(.white)
                .cornerRadius(16)
            Button(action: onRemove) {
                Image(systemName: "xmark.circle.fill")
                    .foregroundColor(.white)
            }
        }
        .padding(4)
    }
}
// MARK: - Barcode Confirmation View
struct BarcodeConfirmationView: View {
    @Binding var barcode: String
    @Binding var productName: String
    @Binding var company: String
    @Binding var price: String
    @Binding var selectedCategory: ProductCategory
    @Binding var isOnSale: Bool
    @Binding var selectedLocation: Location?
    @Binding var showLocationPicker: Bool
    @Binding var showCategoryPicker: Bool
    let availableTags: [Tag]
    @Binding var selectedTags: [Tag]
    @Binding var showingTagPicker: Bool
    @Binding var addToShoppingList: Bool
    @Binding var isExistingProduct: Bool
    let isScanInProgress: Bool
    let onConfirm: (String, String, String, String, ProductCategory, Bool, Location?, [Tag], Bool) -> Void
    let onCancel: () -> Void
    @Environment(\.dismiss) private var dismiss

    // Form validation
    private var isFormValid: Bool {
        !barcode.isEmpty &&
        !productName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !company.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !price.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        selectedLocation != nil &&
        selectedCategory != .none
    }

    private var validationMessages: [String] {
        var messages: [String] = []

        if barcode.isEmpty {
            messages.append("Barcode is required")
        }
        if productName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Product name is required")
        }
        if company.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Company/Brand is required")
        }
        if price.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            messages.append("Price is required")
        }
        if selectedLocation == nil {
            messages.append("Location is required")
        }
        if selectedCategory == .none {
            messages.append("Category is required")
        }

        return messages
    }

    private func shouldShowActionButton() -> Bool {
        // Don't show button during scan processing
        if isScanInProgress {
            return false
        }

        // Always show button when form is valid
        return true
    }

    private func shouldShowUpdateButton() -> Bool {
        return isExistingProduct
    }

    private var buttonText: String {
        return isExistingProduct ? "Update" : "Add"
    }

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {

                    // Form Fields
                    VStack(spacing: 16) {
                        // Barcode Field
                        VStack(spacing: 8) {
                            Text("Barcode Number")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Text(barcode)
                                .font(.system(.body, design: .monospaced))
                                .foregroundColor(AppColors.textPrimary.opacity(0.7))
                        }
                        .frame(maxWidth: .infinity)
                        .multilineTextAlignment(.center)
                        .padding(.bottom, 16)
                        // Product Name Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Product Name")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            TextField("Enter product name...", text: $productName)
                                .font(.body)
                                .padding()
                                .background(AppColors.backgroundSecondary)
                                .cornerRadius(8)
                        }
                        // Company Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Company/Brand")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            TextField("Enter company or brand...", text: $company)
                                .font(.body)
                                .padding()
                                .background(AppColors.backgroundSecondary)
                                .cornerRadius(8)
                        }
                        // Category Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Category")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Button(action: {
                                showCategoryPicker = true
                            }) {
                                HStack {
                                    Text(selectedCategory.rawValue)
                                        .font(.body)
                                        .foregroundColor(.primary)
                                    Spacer()
                                    Image(systemName: "chevron.down")
                                        .foregroundColor(.gray)
                                }
                                .padding()
                                .background(AppColors.backgroundSecondary)
                                .cornerRadius(8)
                            }
                        }
                        // Price Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Price")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            TextField("Enter price...", text: $price)
                                .font(.body)
                                .padding()
                                .background(AppColors.backgroundSecondary)
                                .cornerRadius(8)
                                .keyboardType(.decimalPad)
                        }
                        // Location Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Location")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Button(action: {
                                showLocationPicker = true
                            }) {
                                HStack {
                                    Text(selectedLocation?.name ?? "Select location...")
                                        .font(.body)
                                        .foregroundColor(selectedLocation == nil ? .gray : .primary)
                                    Spacer()
                                    Image(systemName: "chevron.down")
                                        .foregroundColor(.gray)
                                }
                                .padding()
                                .background(AppColors.backgroundSecondary)
                                .cornerRadius(8)
                            }
                        }
                    }
                    .padding(.horizontal)
                    // Tag Selection Field
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Tags")
                            .font(.headline)
                            .foregroundColor(AppColors.textPrimary)
                            .padding(.bottom, 4)
                        Button(action: {
                            showingTagPicker = true
                        }) {
                            HStack {
                                Text(selectedTags.isEmpty ? "Select tags..." : "\(selectedTags.count) tags selected")
                                    .font(.body)
                                    .foregroundColor(selectedTags.isEmpty ? .gray : .primary)
                                Spacer()
                                Image(systemName: "chevron.down")
                                    .foregroundColor(.gray)
                            }
                            .padding()
                            .background(AppColors.backgroundSecondary)
                            .cornerRadius(8)
                        }
                    }
                    .padding(.horizontal)
                    // Selected Tags Display
                    if !selectedTags.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            HStack {
                                Text("Selected Tags")
                                    .font(.headline)
                                    .foregroundColor(AppColors.textPrimary)
                                Spacer()
                                Button("Edit") {
                                    showingTagPicker = true
                                }
                                .font(.subheadline)
                                .foregroundColor(AppColors.accentGreen)
                            }
                            .padding(.bottom, 4)
                            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 8) {
                                ForEach(selectedTags, id: \.id) { tag in
                                    TagChipView(tag: tag) {
                                        selectedTags.removeAll { $0.id == tag.id }
                                    }
                                }
                            }
                        }
                        .padding(.horizontal)
                    }
                    // On Sale Toggle
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("On Sale")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Spacer()
                            Toggle("", isOn: $isOnSale)
                                .toggleStyle(SwitchToggleStyle(tint: AppColors.accentOrange))
                        }
                        .padding(.horizontal)
                    }
                    // Shopping List Toggle
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("Add to Shopping List")
                                .font(.headline)
                                .foregroundColor(AppColors.textPrimary)
                            Spacer()
                            Toggle("", isOn: $addToShoppingList)
                                .toggleStyle(SwitchToggleStyle(tint: AppColors.accentGreen))
                        }
                        .padding(.horizontal)
                        if addToShoppingList {
                            Text("This item will be added to your shopping list")
                                .font(.caption)
                                .foregroundColor(.gray)
                                .padding(.horizontal)
                        }
                    }

                    // Action Buttons - Center Bottom
                    VStack(spacing: 16) {
                        // Always show for testing
                        Button(action: {
                            onConfirm(barcode, productName, company, price, selectedCategory, isOnSale, selectedLocation, selectedTags, addToShoppingList)
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: isExistingProduct ? "arrow.clockwise" : "plus")
                                    .font(.system(size: 18, weight: .semibold))
                                Text(isExistingProduct ? "Update Item" : "Add Item")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(AppColors.accentGreen)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 20)
                    .padding(.bottom, 20)

                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        onCancel()
                    }
                }
            }

        }
    }

}
// MARK: - Manual Barcode Entry View
struct ManualBarcodeEntryView: View {
    @Binding var barcode: String
    let onBarcodeEntered: (String) -> Void
    @Environment(\.dismiss) private var dismiss
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                VStack(spacing: 12) {
                    Image(systemName: "keyboard")
                        .font(.system(size: 40))
                        .foregroundColor(AppColors.accentGreen)
                    Text("Enter Barcode")
                        .font(.title2)
                        .fontWeight(.semibold)
                    Text("Type the barcode number manually")
                        .font(.body)
                        .foregroundColor(AppColors.textPrimary.opacity(0.7))
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                VStack(alignment: .leading, spacing: 8) {
                    Text("Barcode Number")
                        .font(.headline)
                        .foregroundColor(AppColors.textPrimary)
                    TextField("Enter barcode...", text: $barcode)
                        .font(.system(.body, design: .monospaced))
                        .padding()
                        .background(AppColors.backgroundSecondary)
                        .cornerRadius(8)
                        .keyboardType(.numberPad)
                }
                .padding(.horizontal)
                Spacer()
                // Action Buttons
                VStack(spacing: 12) {
                    Button(action: {
                        if !barcode.isEmpty {
                            onBarcodeEntered(barcode)
                        }
                    }) {
                        Text("Add Item")
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(barcode.isEmpty ? Color.gray : AppColors.accentGreen)
                            .cornerRadius(12)
                    }
                    .disabled(barcode.isEmpty)
                    .padding(.horizontal)
                    Button(action: {
                        dismiss()
                    }) {
                        Text("Cancel")
                            .fontWeight(.semibold)
                            .foregroundColor(AppColors.accentGreen)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(AppColors.accentGreen.opacity(0.1))
                            .cornerRadius(12)
                    }
                    .padding(.horizontal)
                }
            }
            .navigationTitle("Manual Entry")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
#Preview {
    AddItemsView(availableTags: []) // Pass an empty array for preview
}
//
//  CameraView.swift
//  CartWise
//
//  Created by Brenna Wilson on 7/12/25.
//
import SwiftUI
import AVFoundation
struct CameraView: UIViewRepresentable {
    let onBarcodeScanned: (String) -> Void
    let onError: (String) -> Void
    func makeUIView(context: Context) -> UIView {
        let view = UIView()
        view.backgroundColor = UIColor.black
        let cameraViewController = CameraViewController()
        cameraViewController.onBarcodeScanned = onBarcodeScanned
        cameraViewController.onError = onError
        // Add camera view controller as child
        context.coordinator.cameraViewController = cameraViewController
        if let cameraView = cameraViewController.view {
            cameraView.translatesAutoresizingMaskIntoConstraints = false
            view.addSubview(cameraView)
            NSLayoutConstraint.activate([
                cameraView.topAnchor.constraint(equalTo: view.topAnchor),
                cameraView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
                cameraView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
                cameraView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
            ])
        }
        return view
    }
    func updateUIView(_ uiView: UIView, context: Context) {
        // No updates needed
    }
    func makeCoordinator() -> Coordinator {
        Coordinator()
    }
    class Coordinator: NSObject {
        var cameraViewController: CameraViewController?
    }
}
//
//  AddLocationView.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import SwiftUI
import CoreData
struct AddLocationView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @EnvironmentObject var productViewModel: ProductViewModel
    @State private var name: String = ""
    @State private var address: String = ""
    @State private var city: String = ""
    @State private var state: String = ""
    @State private var zipCode: String = ""
    @State private var favorited: Bool = false
    @State private var isDefault: Bool = false
    @State private var isLoading: Bool = false
    @State private var showError: Bool = false
    @State private var errorMessage: String = ""
    var body: some View {
        NavigationView {
            ZStack {
                // Background
                AppColors.backgroundSecondary
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: 24) {
                        // Header
                        VStack(spacing: 8) {
                            Image(systemName: "location.circle.fill")
                                .font(.system(size: 48))
                                .foregroundColor(AppColors.accentGreen)
                            Text("Add New Location")
                                .font(.poppins(size: 24, weight: .bold))
                                .foregroundColor(AppColors.textPrimary)
                            Text("Save your favorite shopping locations")
                                .font(.poppins(size: 16, weight: .regular))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.top, 20)
                        // Form
                        VStack(spacing: 20) {
                            // Location Name
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Location Name")
                                    .font(.poppins(size: 16, weight: .semibold))
                                    .foregroundColor(AppColors.textPrimary)
                                TextField("e.g., Home, Work, Mom's House", text: $name)
                                    .textFieldStyle(CustomTextFieldStyle())
                            }
                            // Address
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Street Address")
                                    .font(.poppins(size: 16, weight: .semibold))
                                    .foregroundColor(AppColors.textPrimary)
                                TextField("123 Main Street", text: $address)
                                    .textFieldStyle(CustomTextFieldStyle())
                            }
                            // City, State, Zip Row
                            HStack(spacing: 12) {
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("City")
                                        .font(.poppins(size: 16, weight: .semibold))
                                        .foregroundColor(AppColors.textPrimary)
                                    TextField("City", text: $city)
                                        .textFieldStyle(CustomTextFieldStyle())
                                }
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("State")
                                        .font(.poppins(size: 16, weight: .semibold))
                                        .foregroundColor(AppColors.textPrimary)
                                    TextField("State", text: $state)
                                        .textFieldStyle(CustomTextFieldStyle())
                                }
                            }
                            // Zip Code
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Zip Code")
                                    .font(.poppins(size: 16, weight: .semibold))
                                    .foregroundColor(AppColors.textPrimary)
                                TextField("12345", text: $zipCode)
                                    .textFieldStyle(CustomTextFieldStyle())
                                    .keyboardType(.numberPad)
                            }
                            // Toggle Options
                            VStack(spacing: 16) {
                                Toggle(isOn: $favorited) {
                                    HStack {
                                        Image(systemName: "heart.fill")
                                            .foregroundColor(.red)
                                        Text("Mark as Favorite")
                                            .font(.poppins(size: 16, weight: .medium))
                                            .foregroundColor(AppColors.textPrimary)
                                    }
                                }
                                .toggleStyle(CustomToggleStyle())
                                Toggle(isOn: $isDefault) {
                                    HStack {
                                        Image(systemName: "star.fill")
                                            .foregroundColor(.yellow)
                                        Text("Set as Default Location")
                                            .font(.poppins(size: 16, weight: .medium))
                                            .foregroundColor(AppColors.textPrimary)
                                    }
                                }
                                .toggleStyle(CustomToggleStyle())
                            }
                        }
                        .padding(.horizontal, 20)
                        // Save Button
                        Button(action: saveLocation) {
                            HStack(spacing: 12) {
                                if isLoading {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                        .foregroundColor(.white)
                                } else {
                                    Image(systemName: "plus.circle.fill")
                                        .font(.system(size: 18, weight: .medium))
                                }
                                Text(isLoading ? "Saving..." : "Save Location")
                                    .font(.poppins(size: 18, weight: .semibold))
                            }
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .frame(height: 56)
                            .background(
                                RoundedRectangle(cornerRadius: 18)
                                    .fill(
                                        LinearGradient(
                                            gradient: Gradient(colors: [
                                                AppColors.accentGreen,
                                                AppColors.accentGreen.opacity(0.8)
                                            ]),
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .shadow(color: AppColors.accentGreen.opacity(0.3), radius: 12, x: 0, y: 6)
                            )
                        }
                        .disabled(isLoading || !isFormValid)
                        .opacity(isFormValid ? 1.0 : 0.6)
                        .padding(.horizontal, 20)
                        .padding(.bottom, 32)
                    }
                }
            }
            .navigationTitle("Add Location")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(AppColors.accentGreen)
                }
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
    private var isFormValid: Bool {
        !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !address.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !city.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !state.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !zipCode.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    private func saveLocation() {
        guard isFormValid else { return }
        isLoading = true
        Task {
            do {
                // Get current user
                let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
                fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
                fetchRequest.fetchLimit = 1
                let users = try viewContext.fetch(fetchRequest)
                guard let currentUser = users.first else {
                    throw LocationError.noUserFound
                }
                // If setting as default, unset other defaults
                if isDefault {
                    let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
                    locationFetchRequest.predicate = NSPredicate(format: "user == %@ AND isDefault == YES", currentUser)
                    let existingDefaults = try viewContext.fetch(locationFetchRequest)
                    for existingDefault in existingDefaults {
                        existingDefault.isDefault = false
                    }
                }
                // Create new location
                let location = Location(
                    context: viewContext,
                    id: UUID().uuidString,
                    name: name.trimmingCharacters(in: .whitespacesAndNewlines),
                    address: address.trimmingCharacters(in: .whitespacesAndNewlines),
                    city: city.trimmingCharacters(in: .whitespacesAndNewlines),
                    state: state.trimmingCharacters(in: .whitespacesAndNewlines),
                    zipCode: zipCode.trimmingCharacters(in: .whitespacesAndNewlines),
                    favorited: favorited,
                    isDefault: isDefault
                )
                location.user = currentUser
                try viewContext.save()
                await MainActor.run {
                    isLoading = false
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    errorMessage = error.localizedDescription
                    showError = true
                }
            }
        }
    }
}
// MARK: - Custom Styles
struct CustomTextFieldStyle: TextFieldStyle {
    func _body(configuration: TextField<Self._Label>) -> some View {
        configuration
            .padding(.horizontal, 16)
            .padding(.vertical, 14)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color.white)
                    .shadow(color: Color.black.opacity(0.05), radius: 4, x: 0, y: 2)
            )
            .font(.poppins(size: 16, weight: .regular))
    }
}
struct CustomToggleStyle: ToggleStyle {
    func makeBody(configuration: Configuration) -> some View {
        HStack {
            configuration.label
            Spacer()
            RoundedRectangle(cornerRadius: 20)
                .fill(configuration.isOn ? AppColors.accentGreen : Color.gray.opacity(0.3))
                .frame(width: 50, height: 30)
                .overlay(
                    Circle()
                        .fill(Color.white)
                        .frame(width: 26, height: 26)
                        .offset(x: configuration.isOn ? 10 : -10)
                        .animation(.easeInOut(duration: 0.2), value: configuration.isOn)
                )
                .onTapGesture {
                    withAnimation(.easeInOut(duration: 0.2)) {
                        configuration.isOn.toggle()
                    }
                }
        }
    }
}
// MARK: - Error Types
enum LocationError: Error, LocalizedError {
    case noUserFound
    var errorDescription: String? {
        switch self {
        case .noUserFound:
            return "No user found. Please log in again."
        }
    }
}
//
//  LocationsSectionView.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import SwiftUI
import CoreData
struct LocationsSectionView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @EnvironmentObject var productViewModel: ProductViewModel
    @State private var showAddLocation: Bool = false
    @State private var locations: [Location] = []
    @State private var isLoading: Bool = true
    var body: some View {
        VStack(spacing: 16) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("My Locations")
                        .font(.poppins(size: 20, weight: .bold))
                        .foregroundColor(AppColors.textPrimary)
                    Text("Manage your shopping locations")
                        .font(.poppins(size: 14, weight: .regular))
                        .foregroundColor(.gray)
                }
                Spacer()
                Button(action: {
                    showAddLocation = true
                }) {
                    Image(systemName: "plus.circle.fill")
                        .font(.system(size: 24))
                        .foregroundColor(AppColors.accentGreen)
                }
            }
            // Locations List
            if isLoading {
                VStack(spacing: 12) {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading locations...")
                        .font(.poppins(size: 14, weight: .regular))
                        .foregroundColor(.gray)
                }
                .frame(height: 100)
            } else if locations.isEmpty {
                // Empty State
                VStack(spacing: 16) {
                    Image(systemName: "location.slash")
                        .font(.system(size: 48))
                        .foregroundColor(.gray.opacity(0.6))
                    VStack(spacing: 8) {
                        Text("No Locations Yet")
                            .font(.poppins(size: 18, weight: .semibold))
                            .foregroundColor(AppColors.textPrimary)
                        Text("Add your favorite shopping locations to track prices")
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    Button(action: {
                        showAddLocation = true
                    }) {
                        HStack(spacing: 8) {
                            Image(systemName: "plus.circle.fill")
                                .font(.system(size: 16, weight: .medium))
                            Text("Add First Location")
                                .font(.poppins(size: 16, weight: .semibold))
                        }
                        .foregroundColor(AppColors.accentGreen)
                        .padding(.horizontal, 20)
                        .padding(.vertical, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(AppColors.accentGreen, lineWidth: 2)
                        )
                    }
                }
                .frame(height: 200)
            } else {
                // Locations List
                VStack(spacing: 12) {
                    ForEach(locations.prefix(3)) { location in
                        LocationRowView(location: location)
                    }
                    if locations.count > 3 {
                        Button(action: {
                            // TODO: Navigate to full locations list
                        }) {
                            HStack(spacing: 8) {
                                Text("View All \(locations.count) Locations")
                                    .font(.poppins(size: 14, weight: .medium))
                                Image(systemName: "chevron.right")
                                    .font(.system(size: 12, weight: .medium))
                            }
                            .foregroundColor(AppColors.accentGreen)
                        }
                    }
                }
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.08), radius: 16, x: 0, y: 8)
        )
        .task {
            await loadLocations()
        }
        .sheet(isPresented: $showAddLocation) {
            AddLocationView()
                .environmentObject(productViewModel)
        }
        .onReceive(NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)) { _ in
            Task {
                await loadLocations()
            }
        }
    }
    private func loadLocations() async {
        isLoading = true
        do {
            // Get current user
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try viewContext.fetch(fetchRequest)
            guard let currentUser = users.first else { return }
            // Fetch user's locations
            let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
            locationFetchRequest.predicate = NSPredicate(format: "user == %@", currentUser)
            locationFetchRequest.sortDescriptors = [
                NSSortDescriptor(keyPath: \Location.isDefault, ascending: false),
                NSSortDescriptor(keyPath: \Location.favorited, ascending: false),
                NSSortDescriptor(keyPath: \Location.name, ascending: true)
            ]
            let fetchedLocations = try viewContext.fetch(locationFetchRequest)
            await MainActor.run {
                self.locations = fetchedLocations
                self.isLoading = false
            }
        } catch {
            print("Error loading locations: \(error)")
            await MainActor.run {
                self.isLoading = false
            }
        }
    }
}
struct LocationRowView: View {
    let location: Location
    var body: some View {
        HStack(spacing: 12) {
            // Location Icon
            ZStack {
                Circle()
                    .fill(AppColors.accentGreen.opacity(0.1))
                    .frame(width: 40, height: 40)
                Image(systemName: "location.circle.fill")
                    .font(.system(size: 20))
                    .foregroundColor(AppColors.accentGreen)
            }
            // Location Details
            VStack(alignment: .leading, spacing: 4) {
                HStack(spacing: 8) {
                    Text(location.name ?? "Unknown Location")
                        .font(.poppins(size: 16, weight: .semibold))
                        .foregroundColor(AppColors.textPrimary)
                    if location.isDefault {
                        Image(systemName: "star.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.yellow)
                    }
                    if location.favorited {
                        Image(systemName: "heart.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.red)
                    }
                }
                Text(formatAddress())
                    .font(.poppins(size: 14, weight: .regular))
                    .foregroundColor(.gray)
                    .lineLimit(1)
            }
            Spacer()
            // Arrow
            Image(systemName: "chevron.right")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.gray.opacity(0.6))
        }
        .padding(.vertical, 8)
    }
    private func formatAddress() -> String {
        var components: [String] = []
        if let city = location.city, !city.isEmpty {
            components.append(city)
        }
        if let state = location.state, !state.isEmpty {
            components.append(state)
        }
        if let zipCode = location.zipCode, !zipCode.isEmpty {
            components.append(zipCode)
        }
        return components.isEmpty ? "No address" : components.joined(separator: ", ")
    }
}
//
//  SearchItemsView.swift
//  CartWise
//
//  Created by Serg Tsogtbaatar on 7/5/25.
//  Updated by Kelly Yong on 7/9/25: Added category browsing
//  Enhanced with AI assistance from Cursor AI for UI improvements and category navigation.
//  This saved me 1-2 hours of work implementing the category grid and navigation.
//
import SwiftUI
struct SearchItemsView: View {
    // State variable for search bar input
    @State private var searchText = ""
    @State private var isSearching = false
    @State private var selectedCategory: ProductCategory? = nil
    @State private var selectedTag: Tag? = nil
    @State private var showingTagPicker = false
    @State private var selectedLocation: Location? = nil
    @State private var userLocations: [Location] = []
    @State private var searchProducts: [GroceryItem] = [] // Separate array for search products
    @EnvironmentObject var viewModel: ProductViewModel
    // Computed property for search results that updates automatically
    private var searchResults: [GroceryItem] {
        guard !searchText.isEmpty else { return [] }
        // If a tag is selected, filter from products that have that tag
        let productsToSearch = selectedTag != nil ?
            searchProducts.filter { $0.tagArray.contains(selectedTag!) } :
            searchProducts
        // Filter products to match search text
        let filtered = productsToSearch.filter { product in
            guard let name = product.productName?.lowercased() else { return false }
            return name.contains(searchText.lowercased())
        }
        return filtered
    }
    // Computed property for tag-filtered results
    private var tagFilteredResults: [GroceryItem] {
        guard let selectedTag = selectedTag else { return [] }
        // If we have search text, use searchResults (which already respects the tag)
        if !searchText.isEmpty {
            return searchResults
        }
        // Otherwise filter from all products
        return searchProducts.filter { product in
            product.tagArray.contains(selectedTag)
        }
    }
    // Returns categories matching search text, or all if search is empty
    // Predefined categories
    var filteredCategories: [ProductCategory] {
        let allCategoriesExceptNone = ProductCategory.allCases.filter { $0 != .none }
        if searchText.isEmpty {
            return allCategoriesExceptNone
        } else {
            // Case-insensitive search
            return allCategoriesExceptNone.filter { $0.rawValue.localizedCaseInsensitiveContains(searchText) }
        }
    }
    // Get unique categories from actual products
    var availableCategories: [ProductCategory] {
        let categories = Set(searchProducts.compactMap { groceryItem in
            ProductCategory(rawValue: groceryItem.category ?? "")
        })
        return Array(categories).sorted { $0.rawValue < $1.rawValue }
    }
    var body: some View {
        NavigationStack {
            VStack {
                searchBarView
                if !searchText.isEmpty && !searchResults.isEmpty {
                    searchResultsView
                } else if selectedTag != nil {
                    tagFilteredResultsView
                } else {
                    categoryGridView
                }
            }
            .navigationTitle("Search")
            .onAppear {
                Task {
                    // Load products into local array without affecting viewModel.products
                    await loadSearchProducts()
                    await viewModel.loadTags()
                    await loadUserLocations()
                }
            }
        }
    }
    // MARK: - View Components
    private var searchBarView: some View {
        VStack(spacing: 8) {
            HStack {
                TextField("Search products...", text: $searchText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onChange(of: searchText) { _, newValue in
                        // Real-time filtering is handled by computed properties
                        // No need to call performSearch() as searchResults updates automatically
                    }
                    .onSubmit {
                        Task {
                            await performSearch()
                        }
                    }
                if isSearching {
                    ProgressView()
                        .scaleEffect(0.8)
                }
                if !searchText.isEmpty {
                    Button(action: {
                        searchText = ""
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.gray)
                            .font(.system(size: 18))
                    }
                }
                // Tag filter button
                Button(action: {
                    showingTagPicker = true
                }) {
                    Image(systemName: "line.3.horizontal.decrease.circle")
                        .foregroundColor(selectedTag != nil ? .blue : .gray)
                        .font(.system(size: 20))
                }
                if selectedTag != nil {
                    Button(action: {
                        selectedTag = nil
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(.red)
                            .font(.system(size: 16))
                    }
                }
            }
            .padding(.horizontal)
            .padding(.top)
            // Show selected category if any
            if let selectedCategory = selectedCategory {
                HStack {
                    Text("Category: \(selectedCategory.rawValue)")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.blue)
                    Spacer()
                    .font(.system(size: 12))
                    .foregroundColor(.red)
                }
                .padding(.horizontal)
                .padding(.bottom, 8)
            }
        }
        .sheet(isPresented: $showingTagPicker) {
            SingleTagPickerView(selectedTag: $selectedTag, tags: viewModel.tags)
        }
    }
    private var searchResultsView: some View {
        List(searchResults, id: \.id) { product in
            NavigationLink(destination: ProductDetailView(product: product, selectedLocation: selectedLocation)) {
                SearchResultRowView(product: product)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .listStyle(PlainListStyle())
    }
    private var tagFilteredResultsView: some View {
        VStack {
            if tagFilteredResults.isEmpty {
                VStack(spacing: 20) {
                    Spacer()
                    Image(systemName: "tag")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 60, height: 60)
                        .foregroundColor(.gray.opacity(0.7))
                    Text("No products found with tag '\(selectedTag?.displayName ?? "Unknown")'")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                    Text("Try selecting a different tag or adding tags to products")
                        .font(.system(size: 14))
                        .foregroundColor(.gray.opacity(0.7))
                        .multilineTextAlignment(.center)
                    Spacer()
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .padding(.horizontal, 40)
            } else {
                List(tagFilteredResults, id: \.id) { product in
                    NavigationLink(destination: ProductDetailView(product: product, selectedLocation: selectedLocation)) {
                        SearchResultRowView(product: product)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                .listStyle(PlainListStyle())
            }
        }
    }
    private var categoryGridView: some View {
        ScrollView {
            VStack(spacing: 16) {
                categoryGrid
            }
        }
    }
    private var categoryGrid: some View {
        let columns = Array(repeating: GridItem(.flexible(), spacing: 16), count: 2)
        return LazyVGrid(columns: columns, spacing: 16) {
            ForEach(filteredCategories, id: \.self) { category in
                NavigationLink(destination: CategoryItemsView(category: category)) {
                    CategoryCard(
                        category: category
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding()
    }
    // MARK: - Helper Functions
    private func loadSearchProducts() async {
        // Save current shopping list products
        let currentShoppingListProducts = viewModel.products

        // Load all products temporarily
        await viewModel.loadProducts()

        // Store search products and restore shopping list
        await MainActor.run {
            searchProducts = viewModel.products
            viewModel.products = currentShoppingListProducts
        }
    }

    private func performSearch() async {
        guard !searchText.isEmpty else {
            return
        }
        await MainActor.run {
            isSearching = true
        }
        defer {
            Task { @MainActor in
                isSearching = false
            }
        }

        // Save current shopping list products
        let currentShoppingListProducts = viewModel.products

        // Search Core Data for existing products only (offline-first)
        await viewModel.searchProducts(by: searchText)

        // Update local search products and restore shopping list
        await MainActor.run {
            searchProducts = viewModel.products
            viewModel.products = currentShoppingListProducts
        }

        print("Search completed: \(searchProducts.count) local results")
    }
    private func selectCategory(_ category: ProductCategory) {
        selectedCategory = category
        // Automatically perform search with selected category
        Task {
            await performSearch()
        }
    }
    // MARK: - Helper Functions
    private func loadUserLocations() async {
        await viewModel.loadLocations()
        userLocations = viewModel.locations
        // Set selected location to default or first favorited location
        selectedLocation = userLocations.first { $0.isDefault } ?? userLocations.first { $0.favorited } ?? userLocations.first
    }
}
// MARK: - Search Result Row
struct SearchResultRowView: View {
    @ObservedObject var product: GroceryItem
    var body: some View {
        HStack(spacing: 12) {
                                    // Product image
                        ProductImageView(
                            product: product,
                            size: CGSize(width: 50, height: 50),
                            cornerRadius: 8,
                            showSaleBadge: false
                        )
            VStack(alignment: .leading, spacing: 4) {
                Text(product.productName ?? "Unknown Product")
                    .font(.system(size: 16, weight: .medium))
                    .lineLimit(2)
                if let brand = product.brand, !brand.isEmpty {
                    Text(brand)
                        .font(.system(size: 12))
                        .foregroundColor(.secondary)
                }
                // Show tags if they exist
                if !product.tagArray.isEmpty {
                    TagDisplayView(tags: product.tagArray)
                }
            }
            Spacer()
            VStack(alignment: .trailing, spacing: 4) {
                if let category = product.category {
                    Text(category)
                        .font(.system(size: 12))
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.vertical, 4)
    }
}
// MARK: - Category Card View
struct CategoryCard: View {
    let category: ProductCategory
    var body: some View {
        VStack(spacing: 12) {
            // Category icon
            Image(systemName: iconName)
                .font(.system(size: 32))
                .foregroundStyle(
                    LinearGradient(
                        colors: [.mint, .yellow],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
            // Category name
            Text(category.rawValue)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.primary)
                .multilineTextAlignment(.center)
                .lineLimit(2)
                .minimumScaleFactor(0.8)
        }
        .frame(maxWidth: .infinity, minHeight: 95, maxHeight: 95)
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
    // Icon name for each category - need to change to better icons..
    private var iconName: String {
        switch category {
        case .none: return ""
        case .meat: return "fish"
        case .dairy: return "oval.portrait.fill"
        case .bakery: return "birthday.cake"
        case .produce: return "leaf.fill"
        case .pantry: return "cabinet"
        case .beverages: return "mug.fill"
        case .frozen: return "snowflake"
        case .household: return "house.fill"
        }
    }
}
// MARK: - Single Tag Picker View
struct SingleTagPickerView: View {
    @Binding var selectedTag: Tag?
    let tags: [Tag]
    @Environment(\.dismiss) private var dismiss
    @State private var searchText = ""
    // Search tags
    var filteredTags: [Tag] {
        if searchText.isEmpty {
            return tags
        } else {
            return tags.filter { tag in
                tag.displayName.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    var body: some View {
        NavigationView {
            VStack {
                // Search bar
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField("Search tags...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                .padding(.horizontal)
                .padding(.top)
                List {
                    ForEach(filteredTags, id: \.id) { tag in
                        Button(action: {
                            selectedTag = tag
                            dismiss()
                        }) {
                            HStack {
                                Text(tag.displayName)
                                    .foregroundColor(.primary)
                                Spacer()
                                if selectedTag?.id == tag.id {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
            }
            .navigationTitle("Select Tag")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}
// MARK: - Tag Display View - contains the individual tag chips
struct TagDisplayView: View {
    let tags: [Tag]
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 4) {
                ForEach(tags, id: \.id) { tag in
                    SearchTagChipView(tag: tag)
                }
            }
        }
    }
}
// MARK: - Individual Tag Chip View
struct SearchTagChipView: View {
    let tag: Tag
    var body: some View {
        Text(tag.displayName)
            .font(.system(size: 10))
            .foregroundColor(.secondary)
            .padding(.horizontal, 6)
            .padding(.vertical, 2)
            .background(Color(.systemGray6))
            .cornerRadius(8)
    }
}
#Preview {
    SearchItemsView()
}
//
//  CategoryItemsView.swift
//  CartWise
//
//  Created by Kelly Yong on 7/9/25.
//  Enhanced with AI assistance from Cursor AI for sample data implementation and UI improvements.
//  This saved me 2-3 hours of work implementing product display functionality.
//
import SwiftUI
import CoreData
import Foundation
struct CategoryItemsView: View {
    let category: ProductCategory
    @EnvironmentObject var viewModel: ProductViewModel
    @State private var selectedItemsToAdd: Set<String> = []
    @State private var isLoading = false
    @State private var hasSearched = false
    @State private var categoryProducts: [GroceryItem] = []
    // Location management
    @State private var userLocations: [Location] = []
    @State private var selectedLocation: Location?
    @State private var isLoadingLocations = false
    @State private var showingLocationPicker = false
    @State private var currentUsername: String = "Unknown User"
    private func loadCategoryProducts() async {
        // Load all products and filter by category
        let allProducts = await viewModel.fetchAllProducts()
        let filtered = allProducts.filter { groceryItem in
            // First check if the category field matches
            if let productCategory = groceryItem.category {
                if productCategory.lowercased() == category.rawValue.lowercased() {
                    return true
                }
            }
            // Then check product name against category keywords
            if let productName = groceryItem.productName {
                let categoryKeywords = getCategoryKeywords(for: category)
                let matches = categoryKeywords.contains { keyword in
                    productName.lowercased().contains(keyword.lowercased())
                }
                print("CategoryItemsView: Filtering by name: \(productName) - Keywords: \(categoryKeywords) - Matches: \(matches)")
                return matches
            }
            return false
        }
        print("CategoryItemsView: Total products: \(allProducts.count), Filtered products: \(filtered.count)")

        await MainActor.run {
            categoryProducts = filtered
        }
    }
    private func getCategoryKeywords(for category: ProductCategory) -> [String] {
        switch category {
        case .none:
            return ["grocery", "food"]
        case .meat:
            return ["meat", "seafood", "chicken", "beef", "pork", "fish", "salmon", "turkey"]
        case .dairy:
            return ["dairy", "eggs", "milk", "cheese", "yogurt", "butter", "cream"]
        case .bakery:
            return ["bakery", "bread", "pastry", "cake", "cookie", "muffin", "donut"]
        case .produce:
            return ["produce", "vegetable", "fruit", "fresh", "organic", "apple", "banana", "tomato"]
        case .pantry:
            return ["pantry", "canned", "staple", "rice", "pasta", "sauce", "condiment"]
        case .beverages:
            return ["beverage", "drink", "juice", "soda", "water", "coffee", "tea"]
        case .frozen:
            return ["frozen", "ice cream", "frozen food"]
        case .household:
            return ["household", "personal care", "cleaning", "hygiene", "soap", "shampoo"]
        }
    }
    // Already handles show filtered products
    private var displayProducts: [GroceryItem] {
        return categoryProducts
    }
    // Not sure if Serg wants to keep this logic for showing all products as fallback
    // private var displayProducts: [GroceryItem] {
    //     // If we have filtered products, show them
    //     if !categoryProducts.isEmpty {
    //         return categoryProducts
    //     }
    //     // If we've searched and have products, show all products as they were found for this category
    //     if hasSearched && !viewModel.products.isEmpty {
    //         return viewModel.products
    //     }
    //     // Otherwise, show filtered products (which might be empty)
    //     return categoryProducts
    // }
    var body: some View {
        VStack {
            if isLoading {
                VStack(spacing: 16) {
                    ProgressView()
                        .scaleEffect(1.2)
                    Text("Loading products...")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if displayProducts.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "basket")
                        .resizable()
                        .scaledToFit()
                        .frame(width: 60, height: 60)
                        .foregroundColor(.gray.opacity(0.7))
                    Text("No products found in this category")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(.gray)
                    Text("Products will appear here when available")
                        .font(.system(size: 14))
                        .foregroundColor(.gray.opacity(0.7))
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(displayProducts, id: \.id) { groceryItem in
                            ProductCard(
                                product: groceryItem,
                                isSelected: groceryItem.id != nil && selectedItemsToAdd.contains(groceryItem.id!),
                                onToggle: {
                                    if let productId = groceryItem.id {
                                        if selectedItemsToAdd.contains(productId) {
                                            selectedItemsToAdd.remove(productId)
                                        } else {
                                            selectedItemsToAdd.insert(productId)
                                        }
                                    }
                                },
                                selectedLocation: selectedLocation
                            )
                        }
                    }
                    .padding()
                }
            }
        }
        .navigationTitle(category.rawValue)
        .task {
            // Use .task so it runs once per appearance and cooperates with SwiftUI lifecycle
            isLoading = true
            hasSearched = false
            await loadUserLocations()
            await loadCategoryProducts()
            await searchProductsForCategory()
            isLoading = false
        }
    }
    private func searchProductsForCategory() async {
        // Create a query based on the category
        let categoryQuery = createCategoryQuery(for: category)
        print("CategoryItemsView: Searching for category: \(category.rawValue) with query: \(categoryQuery)")
        // Check initial state
        print("CategoryItemsView: Initial products count: \(categoryProducts.count)")

        // Search for products without mutating global `products`
        let found = await viewModel.searchProductsQuiet(by: categoryQuery)
        print("CategoryItemsView: After search - Found \(found.count) products for category: \(category.rawValue)")

        // Update the category field for the found products to match the current category
        for product in found {
            if product.category == nil || product.category?.isEmpty == true {
                // Update the product's category to match the current category
                let updatedProduct = product
                updatedProduct.category = category.rawValue
                await viewModel.updateProduct(updatedProduct)
            }
        }

        // Merge found results into categoryProducts without flashing
        let merged = (categoryProducts + found).reduce(into: [String: GroceryItem]()) { dict, item in
            if let id = item.id { dict[id] = item }
        }.map { $0.value }
        await MainActor.run {
            categoryProducts = merged
        }
        // Mark that we've searched for this category
        hasSearched = true

        // Print details of each product found
        for (index, product) in found.enumerated() {
            print("  Product \(index + 1): \(product.productName ?? "Unknown") - Category: \(product.category ?? "None")")
        }
        // Check filtered results
        print("CategoryItemsView: Filtered products count: \(categoryProducts.count)")
        for (index, product) in categoryProducts.enumerated() {
            print("  Filtered Product \(index + 1): \(product.productName ?? "Unknown") - Category: \(product.category ?? "None")")
        }
    }
    private func createCategoryQuery(for category: ProductCategory) -> String {
        // Use more specific search terms for better results
        switch category {
        case .none:
            return "grocery food"
        case .meat:
            return "meat seafood"
        case .dairy:
            return "dairy milk cheese"
        case .bakery:
            return "bread bakery"
        case .produce:
            return "fresh vegetables fruits"
        case .pantry:
            return "canned food rice pasta beans"
        case .beverages:
            return "drinks beverages"
        case .frozen:
            return "frozen food"
        case .household:
            return "cleaning supplies"
        }
    }
    // MARK: - Helper Functions
    private func loadUserLocations() async {
        await viewModel.loadLocations()
        userLocations = viewModel.locations
        // Set selected location to default or first favorited location
        selectedLocation = userLocations.first { $0.isDefault } ?? userLocations.first { $0.favorited } ?? userLocations.first
    }
    // private func clearDatabase() async {
    //     // Delete all products from the database
    //     for product in viewModel.products {
    //         await viewModel.deleteProduct(product)
    //     }
    //     print("Database cleared")
    // }
}
// Product Card View
struct ProductCard: View {
    @ObservedObject var product: GroceryItem
    @EnvironmentObject var productViewModel: ProductViewModel
    let isSelected: Bool
    let onToggle: () -> Void
    let selectedLocation: Location?
    // Display product details when tapped
    @State private var showingDetail = false
    var body: some View {
        Button(action: {
            showingDetail = true
        }) {
            HStack(spacing: 12) {
                // Product image
                ProductImageView(
                    product: product,
                    size: CGSize(width: 60, height: 60),
                    cornerRadius: 8,
                    showSaleBadge: false
                )

                VStack(alignment: .leading, spacing: 4) {
                    Text(product.productName ?? "Unknown Product")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.primary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let brand = product.brand {
                        Text(brand)
                            .font(.system(size: 14))
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                    }
                    // Store info removed since we removed store from GroceryItem
                }
                Spacer()
            }
            .padding()
            .frame(height: 100) // Increased height for bigger cards
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showingDetail) {
            ProductDetailView(product: product, selectedLocation: selectedLocation)
        }
    }
}
// Product Detail View
struct ProductDetailView: View {
    @ObservedObject var product: GroceryItem // Use ObservedObject for live updates
    @EnvironmentObject var productViewModel: ProductViewModel
    let selectedLocation: Location?
    // Dismissing the view
    @Environment(\.dismiss) private var dismiss
    // State for delete confirmation
    @State private var showDeleteConfirmation = false
    // State for edit sheet
    @State private var showingEditSheet = false
    // Location picker state
    @State private var userLocations: [Location] = []
    @State private var currentSelectedLocation: Location?
    @State private var showingLocationPicker = false
    @State private var currentUsername: String = "Unknown User"
    // Trigger to force ProductPriceView to refresh
    @State private var priceReloadKey: Int = 0
    // Trigger to force UI updates when product is refreshed
    @State private var productRefreshKey: Int = 0
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .center, spacing: 20) {
                    // Store View
                    StoreView(
                        selectedLocation: currentSelectedLocation ?? selectedLocation,
                        onTap: {
                            showingLocationPicker = true
                        }
                    )

                    Spacer()
                        .frame(height: 20)

                    // Product Name View
                    ProductNameView(product: product)
                                                // Product Image View
                            ProductImageView(
                                product: product,
                                size: CGSize(width: 180, height: 180),
                                cornerRadius: 12,
                                showSaleBadge: true
                            )
                        .padding(.horizontal, 24)
                        .padding(.bottom, 8)
                    // Product Price View
                    // TODO: Need to update data model to include last updated info?
                    ProductPriceView(
                        product: product,
                        currentSelectedLocation: currentSelectedLocation ?? selectedLocation,
                        reloadKey: priceReloadKey
                    )

                    // Add to Shopping List and Add to Favorites View
                    AddToShoppingListAndFavoritesView(
                        product: product,
                        onAddToShoppingList: {},
                        onAddToFavorites: {}
                    )
                    .padding(.bottom, 14)

                    // Product Tags View - Collapsible section
                    ProductTagsView(product: product, refreshKey: productRefreshKey)
                }
                .padding(.horizontal, 24)
            }
            .navigationTitle("Product Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Edit") {
                        showingEditSheet = true
                    }
                    .foregroundColor(.blue)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(.blue)
                }
            }
            .alert("Delete Product", isPresented: $showDeleteConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Delete", role: .destructive) {
                    Task {
                        await deleteProduct()
                    }
                }
            } message: {
                Text("Are you sure you want to delete this product? This action cannot be undone.")
            }
            .onAppear {
                Task {
                    await loadLocationsForDetail()
                    currentUsername = await getCurrentUsername()
                    // Refresh the product to ensure tags are properly loaded
                    await reloadCurrentProduct()
                }
            }
        }
        .sheet(isPresented: $showingLocationPicker) {
            LocationPickerModal(
                locations: userLocations,
                product: product,
                selectedLocation: $currentSelectedLocation,
                onDismiss: { showingLocationPicker = false }
            )
        }
        .sheet(isPresented: $showingEditSheet, onDismiss: {
            // After editing is dismissed, refresh this product instance from Core Data
            Task {
                await reloadCurrentProduct()
                // Nudge price view to reload
                await MainActor.run { priceReloadKey &+= 1 }
            }
        }) {
            ProductEditView(
                product: product,
                onSave: { updatedProduct in
                    Task {
                        // Quietly persist changes
                        await productViewModel.updateProductQuiet(updatedProduct)
                        // Reload the displayed product to reflect freshest values
                        await reloadCurrentProduct()
                        await MainActor.run { priceReloadKey &+= 1 }
                    }
                    showingEditSheet = false
                },
                onCancel: {
                    showingEditSheet = false
                },
                onDelete: {
                    showingEditSheet = false
                    showDeleteConfirmation = true
                }
            )
        }
    }

    // Reload the current product from Core Data to ensure freshest values in this detail view
    private func reloadCurrentProduct() async {
        let context = await CoreDataStack.shared.viewContext
        await MainActor.run {
            // Refresh the managed object to merge latest changes without manual property assignment
            context.refresh(product, mergeChanges: true)

            // Force UI update by incrementing the refresh key
            productRefreshKey += 1
        }
    }

    private func deleteProduct() async {
        do {
            // Permanently delete product from Core Data
            await productViewModel.permanentlyDeleteProduct(product)
            // Force reload products to update UI
            await productViewModel.loadProducts()
            // Dismiss detail view
            dismiss()
        } catch {
            print("Error deleting product: \(error)")
        }
    }
    private func updateProductPrice(product: GroceryItem, newPrice: Double, location: Location?) async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Get the product in the current context
            let productFetchRequest: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            productFetchRequest.predicate = NSPredicate(format: "id == %@", product.id ?? "")
            productFetchRequest.fetchLimit = 1
            let products = try context.fetch(productFetchRequest)
            guard let productInContext = products.first else {
                print("Error: Could not find product in context")
                return
            }
            // Use the provided location or return if no location is selected
            guard let location = location else {
                print("Error: No location selected for price update")
                return
            }
            // Get the location in the current context
            let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
            locationFetchRequest.predicate = NSPredicate(format: "id == %@", location.id ?? "")
            locationFetchRequest.fetchLimit = 1
            let locations = try context.fetch(locationFetchRequest)
            guard let locationInContext = locations.first else {
                print("Error: Could not find location in context")
                return
            }
            // Check if there's an existing price for this product and location
            let priceFetchRequest: NSFetchRequest<GroceryItemPrice> = GroceryItemPrice.fetchRequest()
            priceFetchRequest.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [
                NSPredicate(format: "groceryItem == %@", productInContext),
                NSPredicate(format: "location == %@", locationInContext)
            ])
            priceFetchRequest.fetchLimit = 1
            let existingPrices = try context.fetch(priceFetchRequest)
            if let existingPrice = existingPrices.first {
                // Update existing price for this location
                existingPrice.price = newPrice
                existingPrice.lastUpdated = Date()
                print("Updated existing price for location: \(locationInContext.name ?? "Unknown")")
            } else {
                // Create new price for this specific location
                let newPrice = GroceryItemPrice(
                    context: context,
                    id: UUID().uuidString,
                    price: newPrice,
                    currency: "USD",
                    store: locationInContext.name,
                    groceryItem: productInContext,
                    location: locationInContext,
                    updatedBy: await getCurrentUsername()
                )
                print("Created new price for location: \(locationInContext.name ?? "Unknown")")
            }
            try context.save()
            print("Successfully updated product price to $\(newPrice) for location: \(locationInContext.name ?? "Unknown")")

            // Update user reputation directly in the same context
            let currentUsername = await getCurrentUsername()
            if let currentUser = try context.fetch(NSFetchRequest<UserEntity>(entityName: "UserEntity")).first(where: { $0.username == currentUsername }) {
                // Increment updates count
                currentUser.updates += 1

                // Update level based on new count
                let newLevel = ReputationSystem.shared.getCurrentLevel(updates: Int(currentUser.updates))
                currentUser.level = newLevel.name

                // Save the context to persist the reputation update
                try context.save()

                print("✅ REPUTATION UPDATE: Price update (CategoryItemsView) - user \(currentUsername): \(currentUser.updates) updates, level: \(newLevel.name)")
            } else {
                print("⚠️ WARNING: Could not find current user for reputation update")
            }
        } catch {
            print("Error updating product price: \(error)")
        }
    }
    private func loadLocationsForDetail() async {
        await productViewModel.loadLocations()
        userLocations = productViewModel.locations
        currentSelectedLocation = selectedLocation
    }
    private func getCurrentUsername() async -> String {
        do {
            let context = await CoreDataStack.shared.viewContext
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try context.fetch(fetchRequest)
            if let currentUser = users.first, let username = currentUser.username {
                return username
            }
        } catch {
            print("Error getting current username: \(error)")
        }
        return "Unknown User"
    }
    private func createSocialFeedEntry(product: GroceryItem, newPrice: Double, location: Location?, username: String) async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Get the product in the current context
            let productFetchRequest: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            productFetchRequest.predicate = NSPredicate(format: "id == %@", product.id ?? "")
            productFetchRequest.fetchLimit = 1
            let products = try context.fetch(productFetchRequest)
            guard let productInContext = products.first else {
                print("Error: Could not find product in context for social feed")
                return
            }
            // Get location in the current context
            let locationInContext: Location?
            if let location = location {
                let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
                locationFetchRequest.predicate = NSPredicate(format: "id == %@", location.id ?? "")
                locationFetchRequest.fetchLimit = 1
                let locations = try context.fetch(locationFetchRequest)
                locationInContext = locations.first
            } else {
                locationInContext = nil
            }
            // Get current user in the same context
            let userFetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            userFetchRequest.predicate = NSPredicate(format: "username == %@", username)
            userFetchRequest.fetchLimit = 1
            let users = try context.fetch(userFetchRequest)
            guard let currentUser = users.first else {
                print("Error: Could not find user in context for social feed")
                return
            }
            // Create enhanced comment with all required information
            let storeName = locationInContext?.name ?? "Unknown Store"
            let productName = productInContext.productName ?? "Unknown Product"
            let formattedPrice = String(format: "%.2f", newPrice)
            // Format address
            var addressComponents: [String] = []
            if let address = locationInContext?.address, !address.isEmpty {
                addressComponents.append(address)
            }
            if let city = locationInContext?.city, !city.isEmpty {
                addressComponents.append(city)
            }
            if let state = locationInContext?.state, !state.isEmpty {
                addressComponents.append(state)
            }
            if let zipCode = locationInContext?.zipCode, !zipCode.isEmpty {
                addressComponents.append(zipCode)
            }
            let addressString = addressComponents.isEmpty ? "" : " (\(addressComponents.joined(separator: ", ")))"
            let comment = "Price updated: \(productName) is now $\(formattedPrice) at \(storeName)\(addressString)"
            // Create the social experience
            let experience = ShoppingExperience(
                context: context,
                id: UUID().uuidString,
                comment: comment,
                rating: 0,
                type: "price_update",
                user: currentUser,
                groceryItem: productInContext,
                location: locationInContext
            )
            try context.save()
            print("Successfully created social feed entry for price update: \(productName) at \(storeName)")
        } catch {
            print("Error creating social feed entry: \(error)")
        }
    }
}
// Store view
struct StoreView: View {
    let selectedLocation: Location?
    let onTap: () -> Void
    var body: some View {
        Button(action: onTap) {
            HStack(alignment: .center, spacing: 10) {
                Image(systemName: "mappin.circle")
                    .foregroundColor(.blue)
                Text(selectedLocation?.name ?? "Select Location")
                    .font(.system(size: 14, weight: .bold))
                    .foregroundColor(.black)
                Spacer()
                Text(formatAddress(selectedLocation))
                    .font(.system(size: 12, weight: .regular))
                    .foregroundColor(.gray)
                // Add chevron to indicate it's tappable
                Image(systemName: "chevron.right")
                    .font(.system(size: 12))
                    .foregroundColor(.gray)
            }
            .frame(maxWidth: .infinity, maxHeight: 10, alignment: .center)
            .padding()
            .background(Color.gray.opacity(0.12))
            .cornerRadius(20)
            .shadow(color: Color.black.opacity(0.07), radius: 3, x: 0, y: 2)
            .padding(.horizontal)
        }
        .buttonStyle(PlainButtonStyle())
    }
    private func formatAddress(_ location: Location?) -> String {
        guard let location = location else { return "No location selected" }
        var components: [String] = []
        if let city = location.city, !city.isEmpty {
            components.append(city)
        }
        if let state = location.state, !state.isEmpty {
            components.append(state)
        }
        if let zipCode = location.zipCode, !zipCode.isEmpty {
            components.append(zipCode)
        }
        return components.isEmpty ? "No address" : components.joined(separator: ", ")
    }
}
// Product Name View
struct ProductNameView: View {
    @ObservedObject var product: GroceryItem
    var body: some View {
        VStack(alignment: .center, spacing: 10) {
            // Brand and Store
            HStack {
                // Brand
                if let brand = product.brand {
                    Text(brand)
                        .font(.system(size: 16))
                        .foregroundColor(.secondary)
                }
                // Store info removed since we removed store from GroceryItem
            }
            // Product Name
            Text(product.productName ?? "Unknown Product")
                .font(.system(size: 20, weight: .regular))
                .foregroundColor(.primary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 10)
            // Category info
            VStack(alignment: .leading, spacing: 8) {
                if let category = product.category {
                    Text("Category: \(category)")
                        .font(.system(size: 14))
                        .foregroundColor(.primary)
                        .lineLimit(nil)
                }
            }
        }
    }
}

// Product Price View
struct ProductPriceView: View {
    @ObservedObject var product: GroceryItem
    let currentSelectedLocation: Location?
    // Changing this value will trigger .onChange to reload price
    var reloadKey: Int = 0
    @State private var locationPrice: GroceryItemPrice?
    @State private var isLoading = true

    var body: some View {
        VStack(alignment: .center, spacing: 16) {
            if isLoading {
                ProgressView()
                    .scaleEffect(0.8)
            } else if let locationPrice = locationPrice {
                // Show price for selected location
                VStack(spacing: 8) {
                    Text("$\(String(format: "%.2f", locationPrice.price))")
                        .font(.system(size: 24, weight: .bold))
                        .foregroundColor(.primary)
                    Text("at \(currentSelectedLocation?.name ?? "Unknown Location")")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary)
                    // Last updated info from GroceryItemPrice
                    if let lastUpdated = locationPrice.lastUpdated {
                        VStack(spacing: 2) {
                            Text("Last Updated: \(DateFormatter.localizedString(from: lastUpdated, dateStyle: .short, timeStyle: .short))")
                                .font(.system(size: 12, weight: .regular))
                                .foregroundColor(.gray)
                            if let updatedBy = locationPrice.updatedBy {
                                Text("By: \(updatedBy)")
                                    .font(.system(size: 12, weight: .regular))
                                    .foregroundColor(.gray)
                            }
                        }
                    }
                }
            } else {
                // No price available for selected location
                VStack(spacing: 8) {
                    Text("No price available")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.gray)
                    Text("at \(currentSelectedLocation?.name ?? "Unknown Location")")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary)
                    Text("Tap 'Update Price' to add a price for this location")
                        .font(.system(size: 12))
                        .foregroundColor(.gray.opacity(0.7))
                        .multilineTextAlignment(.center)
                }
            }
        }
        .task {
            await loadPriceForSelectedLocation()
        }
        .onChange(of: reloadKey) { _ in
            Task { await loadPriceForSelectedLocation() }
        }
        .onReceive(NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)) { notification in
            // Only reload if the save involved GroceryItemPrice entities
            if let userInfo = notification.userInfo,
               let insertedObjects = userInfo[NSInsertedObjectsKey] as? Set<NSManagedObject>,
               let updatedObjects = userInfo[NSUpdatedObjectsKey] as? Set<NSManagedObject>,
               let deletedObjects = userInfo[NSDeletedObjectsKey] as? Set<NSManagedObject> {

                let allChangedObjects = insertedObjects.union(updatedObjects).union(deletedObjects)
                let hasPriceChanges = allChangedObjects.contains { object in
                    return object is GroceryItemPrice
                }

                if hasPriceChanges {
                    Task {
                        await loadPriceForSelectedLocation()
                    }
                }
            }
        }
        .onChange(of: currentSelectedLocation) { newLocation in
            Task {
                print("ProductPriceView: Location changed to: \(newLocation?.name ?? "nil")")
                await loadPriceForSelectedLocation(newLocation: newLocation)
            }
        }
    }

    private func loadPriceForSelectedLocation(newLocation: Location? = nil) async {
        isLoading = true
        let locationToSearch = newLocation ?? currentSelectedLocation
        guard let locationToSearch = locationToSearch else {
            await MainActor.run {
                self.locationPrice = nil
                self.isLoading = false
            }
            return
        }
        do {
            let context = await CoreDataStack.shared.viewContext
            let fetchRequest: NSFetchRequest<GroceryItemPrice> = GroceryItemPrice.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "groceryItem == %@ AND location.id == %@", product, locationToSearch.id ?? "")
            // Debug: Let's also check what prices exist for this product
            let allPricesFetchRequest: NSFetchRequest<GroceryItemPrice> = GroceryItemPrice.fetchRequest()
            // Filter out prices with nil or deleted locations
            allPricesFetchRequest.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [
                NSPredicate(format: "groceryItem == %@", product),
                NSPredicate(format: "location != nil")
            ])
            let allPrices = try context.fetch(allPricesFetchRequest)
            print("ProductPriceView: All prices for this product: ")
            for price in allPrices {
                print("  - Location: \(price.location?.name ?? "nil"), ID: \(price.location?.id ?? "nil"), Price: $\(price.price)")
            }
            fetchRequest.fetchLimit = 1
            print("ProductPriceView: Searching for location ID: \(locationToSearch.id ?? "nil")")
            print("ProductPriceView: Searching for location name: \(locationToSearch.name ?? "nil")")
            let prices = try context.fetch(fetchRequest)
            let price = prices.first
            print("ProductPriceView: Found \(prices.count) prices for location \(locationToSearch.name ?? "Unknown")")
            await MainActor.run {
                // Only set locationPrice if we actually found a price
                if let price = price {
                    print("ProductPriceView: Setting price to $\(price.price)")
                    self.locationPrice = price
                } else {
                    print("ProductPriceView: No price found, setting locationPrice to nil")
                    self.locationPrice = nil
                }
                self.isLoading = false
            }
        } catch {
            print("Error loading price for selected location: \(error)")
            await MainActor.run {
                self.locationPrice = nil
                self.isLoading = false
            }
        }
    }
}
// Location Price Row
struct LocationPriceRow: View {
    let price: GroceryItemPrice
    var body: some View {
        HStack(spacing: 12) {
            // Location Icon
            ZStack {
                Circle()
                    .fill(AppColors.accentGreen.opacity(0.1))
                    .frame(width: 32, height: 32)
                Image(systemName: "location.circle.fill")
                    .font(.system(size: 16))
                    .foregroundColor(AppColors.accentGreen)
            }
            // Location and Price Info
            VStack(alignment: .leading, spacing: 2) {
                HStack {
                    Text(price.location?.name ?? "Unknown Location")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(.primary)
                    if let store = price.store, !store.isEmpty {
                        Text("• \(store)")
                            .font(.system(size: 12, weight: .regular))
                            .foregroundColor(.gray)
                    }
                }
                // Last updated info from GroceryItemPrice
                if let lastUpdated = price.lastUpdated {
                    VStack(spacing: 2) {
                        Text("Last Updated: \(DateFormatter.localizedString(from: lastUpdated, dateStyle: .short, timeStyle: .short))")
                            .font(.system(size: 12, weight: .regular))
                            .foregroundColor(.gray)
                        if let updatedBy = price.updatedBy {
                            Text("By: \(updatedBy)")
                                .font(.system(size: 12, weight: .regular))
                                .foregroundColor(.gray)
                        }
                    }
                }
            }
            Spacer()
            // Price
            Text("$\(String(format: "%.2f", price.price))")
                .font(.system(size: 16, weight: .bold))
                .foregroundColor(.primary)
        }
        .padding(.vertical, 4)
    }
}
// Custom Button View
struct CustomButtonView: View {
    let title: String
    let imageName: String
    let fontSize: Int
    let weight: Font.Weight?
    let buttonColor: Color
    let textColor: Color
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(alignment: .center, spacing: 2) {
                Image(systemName: imageName)
                    .font(.system(size: 14))
                    .foregroundColor(textColor)
                Text(title)
                    .font(.system(size: CGFloat(fontSize), weight: weight ?? .regular))
                    .foregroundColor(textColor)
                    .frame(width: 100, height: 10)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 8)
            .background(buttonColor)
            .cornerRadius(8)
        }
    }
}
// Buttons Add to Shopping List and Add to Favorites View
struct AddToShoppingListAndFavoritesView: View {
    @ObservedObject var product: GroceryItem
    @EnvironmentObject var productViewModel: ProductViewModel
    let onAddToShoppingList: () -> Void
    let onAddToFavorites: () -> Void
    @State private var isInShoppingList = false
    @State private var isInFavorites = false
    @State private var isProcessing = false
    @State private var showingFavoriteAlert = false
    @State private var favoriteAlertMessage = ""

    var body: some View {
        HStack(spacing: 14) {
            // Add to List Button - Fixed size to prevent movement
            Button(action: {
                toggleShoppingList()
            }) {
                HStack(spacing: 8) {
                    Image(systemName: isInShoppingList ? "checkmark.circle.fill" : "plus.circle.fill")
                        .font(.system(size: 16))
                    Text(isInShoppingList ? "Added" : "Add to List")
                        .font(.system(size: 15, weight: .bold))
                }
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .frame(height: 44)
                .padding(.horizontal, 16)
                .background(
                    RoundedRectangle(cornerRadius: 22)
                        .fill(isInShoppingList ? Color.accentColorGreen : Color.accentColorBlue)
                )
            }
            .disabled(isProcessing || isInShoppingList)

            Spacer()

            // Add to Favorite Button - Fixed size to prevent movement
            Button(action: {
                toggleFavorites()
            }) {
                HStack(spacing: 8) {
                    Image(systemName: isInFavorites ? "checkmark.circle.fill" : "plus.circle.fill")
                        .font(.system(size: 16))
                    Text("Favorite")
                        .font(.system(size: 15, weight: .bold))
                }
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .frame(height: 44)
                .padding(.horizontal, 16)
                .background(
                    RoundedRectangle(cornerRadius: 22)
                        .fill(isInFavorites ? Color.accentColorCoral : Color.accentColorPink)
                )
            }
            .disabled(isProcessing)
        }
        .padding(.horizontal, 20)
        .padding(.top, 4)
        .task {
            await checkCurrentStatus()
        }
        .onReceive(productViewModel.$products) { _ in
            // Update shopping list status when products change
            Task {
                let newShoppingListStatus = await productViewModel.isProductInShoppingList(name: product.productName ?? "")
                await MainActor.run {
                    isInShoppingList = newShoppingListStatus
                }
            }
        }
        .onReceive(productViewModel.$favoriteProducts) { _ in
            // Update favorites status when favorite products change
            Task {
                let newFavoritesStatus = await productViewModel.isProductInFavorites(product)
                await MainActor.run {
                    isInFavorites = newFavoritesStatus
                }
            }
        }
        .alert("Favorites", isPresented: $showingFavoriteAlert) {
            Button("OK") { }
        } message: {
            Text(favoriteAlertMessage)
        }
    }

    private func checkCurrentStatus() async {
        let shoppingListStatus = await productViewModel.isProductInShoppingList(name: product.productName ?? "")
        let favoritesStatus = await productViewModel.isProductInFavorites(product)

        await MainActor.run {
            isInShoppingList = shoppingListStatus
            isInFavorites = favoritesStatus
        }
    }

    private func toggleShoppingList() {
        guard !isProcessing else { return }

        Task {
            await MainActor.run {
                isProcessing = true
            }

            do {
                // Only allow adding to shopping list, not removing
                if !isInShoppingList {
                    // Add to shopping list
                    await productViewModel.addExistingProductToShoppingListQuiet(product)
                    await MainActor.run {
                        isInShoppingList = true
                        // No alert - just update the button state
                    }
                }
                // If already in shopping list, do nothing (button will be disabled)
            } catch {
                print("Error adding to shopping list: \(error)")
            }

            await MainActor.run {
                isProcessing = false
            }
        }
    }

    private func toggleFavorites() {
        guard !isProcessing else { return }

        Task {
            await MainActor.run {
                isProcessing = true
            }

            do {
                if isInFavorites {
                    // Remove from favorites
                    await productViewModel.removeProductFromFavoritesQuiet(product)
                    await MainActor.run {
                        isInFavorites = false
                        favoriteAlertMessage = "\(product.productName ?? "Product") has been removed from your favorites."
                        showingFavoriteAlert = true
                    }
                } else {
                    // Add to favorites
                    await productViewModel.addProductToFavoritesQuiet(product)
                    await MainActor.run {
                        isInFavorites = true
                        favoriteAlertMessage = "\(product.productName ?? "Product") has been added to your favorites."
                        showingFavoriteAlert = true
                    }
                }
            } catch {
                print("Error toggling favorites: \(error)")
            }

            await MainActor.run {
                isProcessing = false
            }
        }
    }
}
// Update Price View
struct UpdatePriceView: View {
    let product: GroceryItem
    let userName: String
    let onUpdatePrice: (_ newPrice: Double, _ updatedBy: String, _ updatedAt: Date) async -> Void
    let lastUpdated: String
    let lastUpdatedBy: String
    @State private var showSheet: Bool = false
    @State private var priceInput: String = ""
    @State private var showError: Bool = false
    var body: some View {
        VStack(alignment: .center, spacing: 2) {
            Text("Price Inaccurate?")
                .font(.system(size: 17, weight: .bold))
                .foregroundColor(.primary)
                .padding(.top, 2)
            Button(action: {
                showSheet = true
            }) {
                Text("Update Price")
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(AppColors.accentGreen)
                    .padding(.bottom, 6)
            }
        .sheet(isPresented: $showSheet) {
            VStack(spacing: 24) {
                Text("Update Price")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(AppColors.accentGreen)
                    .padding(.vertical, 20)
                // Product name
                Text(product.productName ?? "Unknown Product")
                    .font(.system(size: 18, weight: .regular))
                    .foregroundColor(.primary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 10)
                    .padding(.vertical, 10)
                // No current price display since prices vary by store
                .padding(.bottom, 18)
                // New price input
                VStack(alignment: .leading, spacing: 8) {
                    Text("New Price: ")
                        .font(.system(size: 16, weight: .bold))
                        .foregroundColor(AppColors.accentGreen)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    HStack {
                        Text("$")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(.gray)
                        TextField("0.00", text: $priceInput)
                            .keyboardType(.decimalPad)
                            .font(.system(size: 16, weight: .medium))
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                    }
                    .padding(.bottom, 16)
                }
                .padding(.horizontal, 16)
                if showError {
                    Text("Please enter a valid number.")
                        .foregroundColor(.red)
                        .font(.caption)
                }
                HStack(spacing: 20) {
                    CustomButtonView(
                        title: "Cancel",
                        imageName: "",
                        fontSize: 16,
                        weight: .bold,
                        buttonColor: Color.gray.opacity(0.3),
                        textColor: .primary,
                        action: {
                            showSheet = false
                            priceInput = ""
                            showError = false
                        }
                    )
                    .padding(.horizontal, 18)
                    .padding(.vertical, 18)
                    CustomButtonView(
                        title: "Confirm",
                        imageName: "",
                        fontSize: 16,
                        weight: .bold,
                        buttonColor: AppColors.accentGreen,
                        textColor: .white,
                        action: {
                            if let newPrice = Double(priceInput), newPrice > 0 {
                                Task {
                                    await onUpdatePrice(newPrice, userName, Date())
                                    showSheet = false
                                    priceInput = ""
                                    showError = false
                                }
                            } else {
                                showError = true
                            }
                        }
                    )
                    .padding(.vertical, 18)
                    .disabled(priceInput.isEmpty)
                }
            }
            .padding(.horizontal, 18)
            .interactiveDismissDisabled(true) // Prevent swipe to dismiss
        }
        .padding()
        }
    }
}
// Location Picker Modal
struct LocationPickerModal: View {
    let locations: [Location]
    let product: GroceryItem
    @Binding var selectedLocation: Location?
    let onDismiss: () -> Void
    var body: some View {
        NavigationView {
            VStack(spacing: 16) {
                // Header
                VStack(spacing: 8) {
                    Text("Select Location")
                        .font(.system(size: 20, weight: .bold))
                        .foregroundColor(.primary)
                    Text("Choose from your favorite locations to see different prices")
                        .multilineTextAlignment(.center)
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                }
                .padding(.top, 20)
                .padding(.horizontal, 20)
                // Locations List
                if locations.isEmpty {
                    VStack(spacing: 12) {
                        Image(systemName: "mappin.slash")
                            .font(.system(size: 40))
                            .foregroundColor(.gray.opacity(0.7))
                        Text("No locations found")
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(.gray)
                        Text("Add locations in your profile to see them here")
                            .font(.system(size: 14))
                            .foregroundColor(.gray.opacity(0.7))
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .padding(.horizontal, 20)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(locations, id: \.id) { location in
                                LocationPickerRowView(
                                    location: location,
                                    product: product,
                                    isSelected: selectedLocation?.id == location.id,
                                    onTap: {
                                        selectedLocation = location
                                        onDismiss()
                                    }
                                )
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                    }
                }
                Spacer()
            }
            .padding(.bottom, 20)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Cancel") {
                        onDismiss()
                    }
                }
            }
        }
    }
}
// Location Row View for the picker
struct LocationPickerRowView: View {
    let location: Location
    let product: GroceryItem
    let isSelected: Bool
    let onTap: () -> Void
    @State private var locationPrice: GroceryItemPrice?
    @State private var isLoading = true
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 12) {
                // Location Icon
                ZStack {
                    Circle()
                        .fill(isSelected ? AppColors.accentGreen.opacity(0.2) : Color.gray.opacity(0.1))
                        .frame(width: 40, height: 40)
                    Image(systemName: isSelected ? "checkmark.circle.fill" : "mappin.circle.fill")
                        .font(.system(size: 20))
                        .foregroundColor(isSelected ? AppColors.accentGreen : .gray)
                }
                // Location Info
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(location.name ?? "Unknown Location")
                            .font(.system(size: 16, weight: .semibold))
                            .foregroundColor(.primary)
                        if location.isDefault {
                            Text("Default")
                                .font(.system(size: 10, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(AppColors.accentGreen)
                                .cornerRadius(4)
                        }
                    }
                    Text(formatAddress(location))
                        .font(.system(size: 14))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                }
                Spacer()
                // Price display
                VStack(alignment: .trailing, spacing: 2) {
                    if isLoading {
                        ProgressView()
                            .scaleEffect(0.6)
                    } else if let locationPrice = locationPrice {
                        Text("$\(String(format: "%.2f", locationPrice.price))")
                            .font(.system(size: 16, weight: .bold))
                            .foregroundColor(isSelected ? AppColors.accentGreen : .primary)
                    } else {
                        Text("No price")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundColor(.gray)
                    }
                    if isSelected {
                        Image(systemName: "checkmark")
                            .font(.system(size: 12, weight: .bold))
                            .foregroundColor(AppColors.accentGreen)
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(isSelected ? AppColors.accentGreen.opacity(0.1) : Color(.systemBackground))
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isSelected ? AppColors.accentGreen : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .padding(.horizontal, 4)
        .padding(.vertical, 2)
        .task {
            await loadPriceForLocation()
        }
    }
    private func formatAddress(_ location: Location) -> String {
        var components: [String] = []
        if let city = location.city, !city.isEmpty {
            components.append(city)
        }
        if let state = location.state, !state.isEmpty {
            components.append(state)
        }
        if let zipCode = location.zipCode, !zipCode.isEmpty {
            components.append(zipCode)
        }
        return components.isEmpty ? "No address" : components.joined(separator: ", ")
    }
    private func loadPriceForLocation() async {
        isLoading = true
        do {
            let context = await CoreDataStack.shared.viewContext
            let fetchRequest: NSFetchRequest<GroceryItemPrice> = GroceryItemPrice.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "groceryItem == %@ AND location.id == %@", product, location.id ?? "")
            fetchRequest.fetchLimit = 1
            let prices = try context.fetch(fetchRequest)
            let price = prices.first
            await MainActor.run {
                self.locationPrice = price
                self.isLoading = false
            }
        } catch {
            print("Error loading price for location: \(error)")
            await MainActor.run {
                self.locationPrice = nil
                self.isLoading = false
            }
        }
    }
}

// Product Tags View - Collapsible section
struct ProductTagsView: View {
    @ObservedObject var product: GroceryItem
    @State private var isExpanded = false
    let refreshKey: Int

    var body: some View {
        VStack(spacing: 0) {
            // Header button to toggle expansion (only if there are tags)
            Button(action: {
                if !product.tagArray.isEmpty {
                    withAnimation(.easeInOut(duration: 0.3)) {
                        isExpanded.toggle()
                    }
                }
            }) {
                HStack {
                    Image(systemName: "tag")
                        .font(.system(size: 16))
                        .foregroundColor(.blue)

                    Text("Tags")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.primary)

                    Spacer()

                    Text("\(product.tagArray.count)")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(8)

                    // Only show chevron if there are tags to expand
                    if !product.tagArray.isEmpty {
                        Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(.gray)
                            .rotationEffect(.degrees(isExpanded ? 0 : 0))
                    }
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(Color(.systemBackground))
                .cornerRadius(8)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                )
            }
            .buttonStyle(PlainButtonStyle())
            .disabled(product.tagArray.isEmpty) // Disable button when no tags

            // Collapsible content (only if there are tags and section is expanded)
            if !product.tagArray.isEmpty && isExpanded {
                // Use adaptive grid so chips can expand to fit longer tag names without truncation
                LazyVGrid(columns: [
                    GridItem(.adaptive(minimum: 100), spacing: 8)
                ], spacing: 8) {
                    ForEach(product.tagArray, id: \.id) { tag in
                        ProductTagChipView(tag: tag)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(Color(.systemGray6).opacity(0.5))
                .cornerRadius(8)
                .padding(.top, 4)
            }
        }
        .padding(.horizontal, 4)
        .padding(.vertical, 4)
    }
}

// Tag Chip View for individual tags
struct ProductTagChipView: View {
    let tag: Tag

    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(Color(hex: tag.displayColor))
                .frame(width: 8, height: 8)

            Text(tag.displayName)
                .font(.system(size: 12, weight: .medium))
                .foregroundColor(.primary)
                .lineLimit(nil)
                .fixedSize(horizontal: false, vertical: true)
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color(hex: tag.displayColor).opacity(0.3), lineWidth: 1)
        )
    }
}

// Product Edit View
struct ProductEditView: View {
    @ObservedObject var product: GroceryItem
    @EnvironmentObject var productViewModel: ProductViewModel
    let onSave: (GroceryItem) -> Void
    let onCancel: () -> Void
    let onDelete: () -> Void
    @Environment(\.dismiss) private var dismiss

    // Form state
    @State private var productName: String = ""
    @State private var brand: String = ""
    @State private var category: ProductCategory = .none
    @State private var price: String = ""
    @State private var selectedLocation: Location?
    @State private var isOnSale: Bool = false
    @State private var selectedTags: [Tag] = []

    // UI state
    @State private var showLocationPicker = false
    @State private var showingTagPicker = false
    @State private var availableTags: [Tag] = []
    @State private var userLocations: [Location] = []

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Add spacing after header
                    Spacer()
                        .frame(height: 20)

                    // Form Fields
                    VStack(spacing: 16) {
                        // Product Name Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Product Name")
                                .font(.headline)
                                .foregroundColor(.primary)
                            TextField("Enter product name...", text: $productName)
                                .font(.body)
                                .padding()
                                .background(Color(UIColor.systemGray6))
                                .cornerRadius(8)
                        }

                        // Brand Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Company/Brand")
                                .font(.headline)
                                .foregroundColor(.primary)
                            TextField("Enter company or brand...", text: $brand)
                                .font(.body)
                                .padding()
                                .background(Color(UIColor.systemGray6))
                                .cornerRadius(8)
                        }

                        // Price Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Price")
                                .font(.headline)
                                .foregroundColor(.primary)
                            TextField("Enter price...", text: $price)
                                .font(.body)
                                .padding()
                                .background(Color(UIColor.systemGray6))
                                .cornerRadius(8)
                                .keyboardType(.decimalPad)
                        }

                        // Location Field
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Location")
                                .font(.headline)
                                .foregroundColor(.primary)
                            Button(action: {
                                showLocationPicker = true
                            }) {
                                HStack {
                                    Text(selectedLocation?.name ?? "Select location...")
                                        .font(.body)
                                        .foregroundColor(selectedLocation == nil ? .gray : .primary)
                                    Spacer()
                                    Image(systemName: "chevron.down")
                                        .foregroundColor(.gray)
                                }
                                .padding()
                                .background(Color(UIColor.systemGray6))
                                .cornerRadius(8)
                            }
                        }
                    }
                    .padding(.horizontal)

                    // Selected Tags Display
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("Tags")
                                .font(.headline)
                                .foregroundColor(.primary)
                            Spacer()
                            Button("Edit") {
                                showingTagPicker = true
                            }
                            .font(.subheadline)
                            .foregroundColor(.blue)
                        }
                        .padding(.bottom, 4)
                        if selectedTags.isEmpty {
                            Text("No tags selected")
                                .font(.body)
                                .foregroundColor(.gray)
                                .padding(.vertical, 8)
                        } else {
                            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 2), spacing: 8) {
                                ForEach(selectedTags, id: \.id) { tag in
                                    ProductTagChipView(tag: tag)
                                }
                            }
                        }
                    }
                    .padding(.horizontal)

                    // On Sale Toggle
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("On Sale")
                                .font(.headline)
                                .foregroundColor(.primary)
                            Spacer()
                            Toggle("", isOn: $isOnSale)
                                .toggleStyle(SwitchToggleStyle(tint: .orange))
                        }
                        .padding(.horizontal)
                    }

                    Spacer()
                        .frame(height: 20)

                    // Action Buttons
                    VStack(spacing: 16) {
                        // Save Button
                        Button(action: {
                            saveChanges()
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: "checkmark")
                                    .font(.system(size: 18, weight: .semibold))
                                Text("Save Changes")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(Color.accentColorGreen)
                            .cornerRadius(12)
                        }

                        // Delete Button
                        Button(action: {
                            onDelete()
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: "trash")
                                    .font(.system(size: 18, weight: .semibold))
                                Text("Delete Product")
                                    .font(.system(size: 18, weight: .semibold))
                            }
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(Color.red)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 20)
                    .padding(.bottom, 20)
                }
            }
            .navigationTitle("Edit Product")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        onCancel()
                    }
                }
            }
        }
        .onAppear {
            loadProductData()
            loadAvailableData()
        }
        .sheet(isPresented: $showLocationPicker) {
            LocationPickerModal(
                locations: userLocations,
                product: product,
                selectedLocation: $selectedLocation,
                onDismiss: { showLocationPicker = false }
            )
        }
        .sheet(isPresented: $showingTagPicker) {
            ProductEditTagPickerView(
                availableTags: availableTags,
                selectedTags: $selectedTags,
                onDone: { showingTagPicker = false }
            )
        }
    }

    private func loadProductData() {
        productName = product.productName ?? ""
        brand = product.brand ?? ""
        category = ProductCategory(rawValue: product.category ?? "") ?? .none
        isOnSale = product.isOnSale

        // Get the most recent VALID price and location (ignore orphaned prices with missing/deleted locations)
        if let prices = product.prices as? Set<GroceryItemPrice> {
            let validPrices = prices.filter { price in
                guard let loc = price.location else { return false }
                return !loc.isDeleted
            }
            if let mostRecentPrice = validPrices.max(by: { ($0.lastUpdated ?? Date.distantPast) < ($1.lastUpdated ?? Date.distantPast) }) {
                price = String(format: "%.2f", mostRecentPrice.price)
                selectedLocation = mostRecentPrice.location
            } else {
                // No valid price — clear fields
                price = ""
                selectedLocation = nil
            }
        }

        // Load existing tags
        if let existingTags = product.tags as? Set<Tag> {
            selectedTags = Array(existingTags)
        }
    }

    private func loadAvailableData() {
        Task {
            await loadLocations()
            await loadTags()
        }
    }

    private func loadLocations() async {
        await productViewModel.loadLocations()
        await MainActor.run {
            userLocations = productViewModel.locations
        }
    }

    private func loadTags() async {
        await productViewModel.loadTags()
        await MainActor.run {
            availableTags = productViewModel.tags
        }
    }

    private func saveChanges() {
        // Update the product with new values
        product.productName = productName
        product.brand = brand
        product.category = category.rawValue
        product.isOnSale = isOnSale

        // Update price if location is selected (use repository so reputation updates)
        if let location = selectedLocation, let priceValue = Double(price) {
            Task {
                await productViewModel.updateProductPrice(
                    product,
                    price: priceValue,
                    store: location.name ?? "Unknown Store",
                    locationAddress: location.address
                )
            }
        }

        // Update tags
        product.tags = NSSet(array: selectedTags)

        onSave(product)
    }

    private func updateProductPrice(product: GroceryItem, newPrice: Double, location: Location) async {
        do {
            let context = await CoreDataStack.shared.viewContext
            // Get the product in the current context
            let productFetchRequest: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
            productFetchRequest.predicate = NSPredicate(format: "id == %@", product.id ?? "")
            productFetchRequest.fetchLimit = 1
            let products = try context.fetch(productFetchRequest)
            guard let productInContext = products.first else {
                print("Error: Could not find product in context")
                return
            }

            // Get the location in the current context
            let locationFetchRequest: NSFetchRequest<Location> = Location.fetchRequest()
            locationFetchRequest.predicate = NSPredicate(format: "id == %@", location.id ?? "")
            locationFetchRequest.fetchLimit = 1
            let locations = try context.fetch(locationFetchRequest)
            guard let locationInContext = locations.first else {
                print("Error: Could not find location in context")
                return
            }

            // Check if there's an existing price for this product and location
            let priceFetchRequest: NSFetchRequest<GroceryItemPrice> = GroceryItemPrice.fetchRequest()
            priceFetchRequest.predicate = NSPredicate(format: "groceryItem == %@ AND location.id == %@", productInContext, locationInContext.id ?? "")
            priceFetchRequest.fetchLimit = 1
            let existingPrices = try context.fetch(priceFetchRequest)

            if let existingPrice = existingPrices.first {
                // Update existing price for this location
                existingPrice.price = newPrice
                existingPrice.lastUpdated = Date()
                print("Updated existing price for location: \(locationInContext.name ?? "Unknown")")
            } else {
                // Create new price for this specific location
                let newPrice = GroceryItemPrice(
                    context: context,
                    id: UUID().uuidString,
                    price: newPrice,
                    currency: "USD",
                    store: locationInContext.name,
                    groceryItem: productInContext,
                    location: locationInContext,
                    updatedBy: await getCurrentUsername()
                )
                print("Created new price for location: \(locationInContext.name ?? "Unknown")")
            }

            try context.save()
            print("Successfully updated product price to $\(newPrice) for location: \(locationInContext.name ?? "Unknown")")
        } catch {
            print("Error updating product price: \(error)")
        }
    }

    private func getCurrentUsername() async -> String {
        do {
            let context = await CoreDataStack.shared.viewContext
            let fetchRequest: NSFetchRequest<UserEntity> = UserEntity.fetchRequest()
            fetchRequest.sortDescriptors = [NSSortDescriptor(keyPath: \UserEntity.createdAt, ascending: false)]
            fetchRequest.fetchLimit = 1
            let users = try context.fetch(fetchRequest)
            if let currentUser = users.first, let username = currentUser.username {
                return username
            }
        } catch {
            print("Error getting current username: \(error)")
        }
        return "Unknown User"
    }
}

// Product Edit Tag Picker View
struct ProductEditTagPickerView: View {
    let availableTags: [Tag]
    @Binding var selectedTags: [Tag]
    let onDone: () -> Void
    @Environment(\.dismiss) private var dismiss

    @State private var searchText = ""

    var filteredTags: [Tag] {
        if searchText.isEmpty {
            return availableTags
        } else {
            return availableTags.filter { tag in
                tag.displayName.localizedCaseInsensitiveContains(searchText)
            }
        }
    }

    var body: some View {
        NavigationView {
            VStack {
                // Search bar
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField("Search tags...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())

                    if !searchText.isEmpty {
                        Button(action: {
                            searchText = ""
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.gray)
                        }
                    }
                }
                .padding(.horizontal)
                .padding(.top)

                if availableTags.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "tag.slash")
                            .font(.system(size: 40))
                            .foregroundColor(.gray.opacity(0.7))
                        Text("No tags available")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(.gray)
                        Text("Create tags in your profile to see them here")
                            .font(.system(size: 14))
                            .foregroundColor(.gray.opacity(0.7))
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    List {
                        ForEach(filteredTags, id: \.id) { tag in
                            Button(action: {
                                if selectedTags.contains(where: { $0.id == tag.id }) {
                                    selectedTags.removeAll { $0.id == tag.id }
                                } else {
                                    selectedTags.append(tag)
                                }
                            }) {
                                HStack {
                                    Circle()
                                        .fill(Color(hex: tag.displayColor))
                                        .frame(width: 12, height: 12)
                                    Text(tag.displayName)
                                        .foregroundColor(.primary)
                                    Spacer()
                                    if selectedTags.contains(where: { $0.id == tag.id }) {
                                        Image(systemName: "checkmark")
                                            .foregroundColor(.blue)
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle("Select Tags")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        onDone()
                    }
                }
            }
        }
    }
}
//
//  SignUpView.swift
//  CartWise
//
//  Created by Alex Kumar on 7/13/25.
//
import SwiftUI
struct SignUpView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var viewModel: AuthViewModel
    @AppStorage("isLoggedIn") private var isLoggedIn: Bool = false
    @State private var username = ""
    @State private var password = ""
    init() {
        _viewModel = StateObject(wrappedValue: AuthViewModel(context: PersistenceController.shared.container.viewContext))
    }
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Shopping Cart Icon
                Image(systemName: "cart.fill")
                    .font(.system(size: 60))
                    .foregroundColor(AppColors.accentGreen)
                    .padding(.top, 50)
                Text("CartWise")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(AppColors.textPrimary)
                    .padding(.top, 10)
                Spacer()
                VStack(spacing: 20) {
                    VStack(alignment: .leading, spacing: 5) {
                        Text("Username")
                            .font(.headline)
                            .foregroundColor(AppColors.textPrimary)
                        TextField("Enter username", text: $username)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .autocapitalization(.none)
                            .textContentType(.username)
                    }
                    VStack(alignment: .leading, spacing: 5) {
                        Text("Password")
                            .font(.headline)
                            .foregroundColor(AppColors.textPrimary)
                        SecureField("Enter password", text: $password)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .textContentType(.password)
                    }
                }
                .padding(.horizontal)
                if let error = viewModel.error {
                    Text(error)
                        .foregroundColor(AppColors.accentRed)
                        .font(.caption)
                        .padding(.horizontal)
                }
                Button(action: {
                    Task {
                        print("Sign up button tapped with username: \(username)")
                        await viewModel.signUp(username: username, password: password)
                        print("Sign up completed. User: \(String(describing: viewModel.user)), Error: \(String(describing: viewModel.error))")
                        if viewModel.user != nil {
                            isLoggedIn = true
                            print("User signed up successfully")
                        }
                    }
                }) {
                    if viewModel.isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle(tint: AppColors.textSecondary))
                            .scaleEffect(0.8)
                    } else {
                        Text("Sign Up")
                            .fontWeight(.semibold)
                            .foregroundColor(AppColors.textSecondary)
                    }
                }
                .frame(maxWidth: .infinity)
                .frame(height: 50)
                .background(AppColors.accentGreen)
                .cornerRadius(10)
                .padding(.horizontal)
                .disabled(viewModel.isLoading || username.isEmpty || password.isEmpty)
                NavigationLink("Already have an account? Log In", destination: LoginView())
                    .foregroundColor(AppColors.textPrimary)
                    .font(.system(size: 16, weight: .medium))
                    .padding(.top, 10)
                Spacer()
            }
            .background(AppColors.backgroundPrimary)
            .navigationTitle("Sign Up")
            .navigationBarHidden(true)
        }
    }
}
// Preview
struct SignUpView_Previews: PreviewProvider {
    static var previews: some View {
        SignUpView()
            .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
    }
}
//
//  SocialFeedView.swift
//  CartWise
//
//  Created by AI Assistant on 12/19/24.
//
import SwiftUI
import CoreData
struct SocialFeedView: View {
    @StateObject private var viewModel = SocialFeedViewModel()
    @State private var showingAddExperience = false
    @State private var selectedExperience: ShoppingExperience?
    var body: some View {
        NavigationView {
            VStack {
                if viewModel.isLoading {
                    ProgressView("Loading feed...")
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else if viewModel.experiences.isEmpty {
                    VStack(spacing: 20) {
                        Image(systemName: "bubble.left.and.bubble.right")
                            .font(.system(size: 60))
                            .foregroundColor(.gray)
                        Text("No experiences yet")
                            .font(.title2)
                            .fontWeight(.medium)
                            .foregroundColor(.gray)
                        Text("Be the first to share your shopping experience!")
                            .font(.body)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 16) {
                            ForEach(viewModel.experiences) { experience in
                                ExperienceCardView(experience: experience, viewModel: viewModel)
                                    .onTapGesture {
                                        selectedExperience = experience
                                    }
                            }
                        }
                        .padding()
                    }
                }
            }
            .navigationTitle("Social Feed")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showingAddExperience = true
                    }) {
                        Image(systemName: "plus.circle.fill")
                            .font(.title2)
                    }
                }
            }
            .sheet(isPresented: $showingAddExperience) {
                AddExperienceView(viewModel: viewModel)
            }
            .sheet(item: $selectedExperience) { experience in
                ExperienceDetailView(experience: experience, viewModel: viewModel)
            }
            .refreshable {
                viewModel.loadExperiences()
            }
        }
        .onAppear {
            viewModel.loadExperiences()
        }
    }
}
struct ExperienceCardView: View {
    let experience: ShoppingExperience
    let viewModel: SocialFeedViewModel
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(experience.user?.username ?? "Anonymous")
                        .font(.headline)
                        .fontWeight(.semibold)
                    Text(viewModel.formatDate(experience.createdAt))
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                Spacer()
                // Type badge
                Text(experience.displayType)
                    .font(.caption)
                    .fontWeight(.medium)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(typeColor.opacity(0.2))
                    .foregroundColor(typeColor)
                    .cornerRadius(8)
            }
            // Content
            VStack(alignment: .leading, spacing: 8) {
                Text(experience.comment ?? "")
                    .font(.body)
                    .multilineTextAlignment(.leading)
                if experience.rating > 0 {
                    HStack {
                        Text(viewModel.formatRating(experience.rating))
                            .font(.caption)
                            .foregroundColor(.orange)
                        Spacer()
                    }
                }
                // Related item/location info
                if let groceryItem = experience.groceryItem {
                    HStack {
                        Image(systemName: "tag.fill")
                            .foregroundColor(.blue)
                        Text(groceryItem.productName ?? "Unknown Product")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                } else if let location = experience.location {
                    HStack {
                        Image(systemName: "mappin.circle.fill")
                            .foregroundColor(.red)
                        Text(location.name ?? "Unknown Location")
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                }
            }
            // Comments count
            if !experience.commentArray.isEmpty {
                HStack {
                    Image(systemName: "bubble.left")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Text("\(experience.commentArray.count) comments")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Spacer()
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
    }
    private var typeColor: Color {
        switch experience.type {
        case "price_update":
            return .green
        case "store_review":
            return .orange
        case "product_review":
            return .blue
        case "general":
            return .purple
        case "new_product":
            return .teal
        default:
            return .gray
        }
    }
}
struct AddExperienceView: View {
    @ObservedObject var viewModel: SocialFeedViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @State private var comment = ""
    @State private var rating: Int16 = 0
    @State private var selectedType = "general"
    @State private var showingTypePicker = false
    // Optional fields for additional information
    @State private var selectedProduct: GroceryItem?
    @State private var selectedLocation: Location?
    @State private var price: String = ""
    @State private var showingProductPicker = false
    @State private var showingLocationPicker = false
    // Available products and locations
    @State private var availableProducts: [GroceryItem] = []
    @State private var availableLocations: [Location] = []
    private let types = [
        ("general", "General Comment"),
        ("price_update", "Price Update"),
        ("store_review", "Store Review"),
        ("product_review", "Product Review")
    ]
    var body: some View {
        NavigationView {
            Form {
                Section("Experience Details") {
                    Picker("Type", selection: $selectedType) {
                        ForEach(types, id: \.0) { type in
                            Text(type.1).tag(type.0)
                        }
                    }
                    .pickerStyle(.menu)
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Rating")
                            .font(.headline)
                        HStack(spacing: 12) {
                            ForEach(1...5, id: \.self) { star in
                                Button(action: {
                                    // If tapping the same star, clear the rating, otherwise set to the tapped star
                                    rating = rating == Int16(star) ? 0 : Int16(star)
                                }) {
                                    Image(systemName: star <= rating ? "star.fill" : "star")
                                        .foregroundColor(star <= rating ? .orange : .gray)
                                        .font(.title2)
                                        .frame(width: 32, height: 32)
                                        .contentShape(Rectangle())
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                }
                // Optional Product Information
                if selectedType == "product_review" || selectedType == "price_update" {
                    Section("Product Information (Optional)") {
                        Button(action: {
                            loadAvailableProducts()
                            showingProductPicker = true
                        }) {
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Product")
                                        .font(.headline)
                                    Text(selectedProduct?.productName ?? "Select a product")
                                        .font(.subheadline)
                                        .foregroundColor(selectedProduct == nil ? .gray : .primary)
                                }
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .foregroundColor(.gray)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        if selectedProduct != nil {
                            Button("Clear Product") {
                                selectedProduct = nil
                            }
                            .foregroundColor(.red)
                        }
                    }
                }
                // Optional Store Information
                if selectedType == "store_review" || selectedType == "price_update" {
                    Section("Store Information (Optional)") {
                        Button(action: {
                            loadAvailableLocations()
                            showingLocationPicker = true
                        }) {
                            HStack {
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Store")
                                        .font(.headline)
                                    Text(selectedLocation?.name ?? "Select a store")
                                        .font(.subheadline)
                                        .foregroundColor(selectedLocation == nil ? .gray : .primary)
                                }
                                Spacer()
                                Image(systemName: "chevron.right")
                                    .foregroundColor(.gray)
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        if selectedLocation != nil {
                            Button("Clear Store") {
                                selectedLocation = nil
                            }
                            .foregroundColor(.red)
                        }
                    }
                }
                // Optional Price Information
                if selectedType == "price_update" {
                    Section("Price Information (Optional)") {
                        HStack {
                            Text("$")
                                .font(.headline)
                                .foregroundColor(.gray)
                            TextField("0.00", text: $price)
                                .keyboardType(.decimalPad)
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                        }
                    }
                }
                Section("Comment") {
                    TextEditor(text: $comment)
                        .frame(minHeight: 100)
                }
            }
            .navigationTitle("Add Experience")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Post") {
                        postExperience()
                    }
                    .disabled(comment.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
            .sheet(isPresented: $showingProductPicker) {
                ProductPickerView(selectedProduct: $selectedProduct)
            }
            .sheet(isPresented: $showingLocationPicker) {
                LocationPickerView(selectedLocation: $selectedLocation)
            }
        }
    }
    private func postExperience() {
        // Create enhanced comment with optional information
        var enhancedComment = comment.trimmingCharacters(in: .whitespacesAndNewlines)
        // Add product information if available
        if let product = selectedProduct {
            enhancedComment += "\n\nProduct: \(product.productName ?? "Unknown")"
            if let brand = product.brand, !brand.isEmpty {
                enhancedComment += " (\(brand))"
            }
        }
        // Add store information if available
        if let location = selectedLocation {
            enhancedComment += "\nStore: \(location.name ?? "Unknown")"
            if let address = location.address, !address.isEmpty {
                enhancedComment += " (\(address))"
            }
        }
        // Add price information if available
        if !price.isEmpty, let priceValue = Double(price) {
            enhancedComment += "\nPrice: $\(String(format: "%.2f", priceValue))"
        }
        // Get current user from the same context
        let currentUser = viewModel.getCurrentUser()
        viewModel.createExperience(
            comment: enhancedComment,
            rating: rating,
            type: selectedType,
            groceryItem: selectedProduct,
            location: selectedLocation,
            user: currentUser
        )
        dismiss()
    }
    // MARK: - Helper Methods
    private func loadAvailableProducts() {
        let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.productName, ascending: true)]
        do {
            availableProducts = try viewContext.fetch(request)
        } catch {
            print("Failed to load products: \(error)")
        }
    }
    private func loadAvailableLocations() {
        let request: NSFetchRequest<Location> = Location.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \Location.name, ascending: true)]
        do {
            availableLocations = try viewContext.fetch(request)
        } catch {
            print("Failed to load locations: \(error)")
        }
    }
}
// MARK: - Product Picker View
struct ProductPickerView: View {
    @Binding var selectedProduct: GroceryItem?
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @State private var searchText = ""
    @State private var products: [GroceryItem] = []
    @State private var isLoading = true
    var filteredProducts: [GroceryItem] {
        if searchText.isEmpty {
            return products
        }
        return products.filter { product in
            let nameMatch = product.productName?.localizedCaseInsensitiveContains(searchText) == true
            let brandMatch = product.brand?.localizedCaseInsensitiveContains(searchText) == true
            let categoryMatch = product.category?.localizedCaseInsensitiveContains(searchText) == true
            return nameMatch || brandMatch || categoryMatch
        }
    }
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Search Bar
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.gray)
                    TextField("Search products...", text: $searchText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                .padding(.horizontal)
                .padding(.top)
                if isLoading {
                    Spacer()
                    VStack(spacing: 12) {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading products...")
                            .font(.poppins(size: 14, weight: .regular))
                            .foregroundColor(.gray)
                    }
                    Spacer()
                } else if products.isEmpty {
                    // Empty State
                    Spacer()
                    VStack(spacing: 16) {
                        Image(systemName: "cart")
                            .font(.system(size: 48))
                            .foregroundColor(.gray.opacity(0.6))
                        VStack(spacing: 8) {
                            Text("No Products Found")
                                .font(.poppins(size: 18, weight: .semibold))
                                .foregroundColor(.primary)
                            Text("Add products to your shopping list first")
                                .font(.poppins(size: 14, weight: .regular))
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                    }
                    Spacer()
                } else {
                    // Products List
                    List {
                        ForEach(filteredProducts, id: \.id) { product in
                            Button(action: {
                                selectedProduct = product
                                dismiss()
                            }) {
                                HStack {
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text(product.productName ?? "Unknown Product")
                                            .font(.headline)
                                            .foregroundColor(.primary)
                                        if let brand = product.brand, !brand.isEmpty {
                                            Text(brand)
                                                .font(.subheadline)
                                                .foregroundColor(.gray)
                                        }
                                        if let category = product.category, !category.isEmpty {
                                            Text(category)
                                                .font(.caption)
                                                .foregroundColor(.gray.opacity(0.7))
                                        }
                                    }
                                    Spacer()
                                    if selectedProduct?.id == product.id {
                                        Image(systemName: "checkmark")
                                            .foregroundColor(.green)
                                    }
                                }
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                }
            }
            .navigationTitle("Select Product")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .onAppear {
                loadProducts()
            }
        }
    }
    private func loadProducts() {
        let request: NSFetchRequest<GroceryItem> = GroceryItem.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(keyPath: \GroceryItem.productName, ascending: true)]
        do {
            products = try viewContext.fetch(request)
            isLoading = false
        } catch {
            print("Failed to load products: \(error)")
            isLoading = false
        }
    }
}
struct ExperienceDetailView: View {
    let experience: ShoppingExperience
    @ObservedObject var viewModel: SocialFeedViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var newComment = ""
    @State private var newRating: Int16 = 0
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Main experience
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            VStack(alignment: .leading, spacing: 4) {
                                Text(experience.user?.username ?? "Anonymous")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                Text(viewModel.formatDate(experience.createdAt))
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            Spacer()
                            Text(experience.displayType)
                                .font(.caption)
                                .fontWeight(.medium)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.blue.opacity(0.2))
                                .foregroundColor(.blue)
                                .cornerRadius(8)
                        }
                        Text(experience.comment ?? "")
                            .font(.body)
                        if experience.rating > 0 {
                            Text(viewModel.formatRating(experience.rating))
                                .font(.caption)
                                .foregroundColor(.orange)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    // Comments
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Comments (\(experience.commentArray.count))")
                            .font(.headline)
                            .fontWeight(.semibold)
                        if experience.commentArray.isEmpty {
                            Text("No comments yet")
                                .font(.body)
                                .foregroundColor(.gray)
                                .italic()
                        } else {
                            ForEach(experience.commentArray) { comment in
                                CommentView(comment: comment, viewModel: viewModel)
                            }
                        }
                    }
                    // Add comment section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Add Comment")
                            .font(.headline)
                            .fontWeight(.semibold)
                        VStack(alignment: .leading, spacing: 8) {
                            HStack(spacing: 12) {
                                ForEach(1...5, id: \.self) { star in
                                    Button(action: {
                                        // If tapping the same star, clear the rating, otherwise set to the tapped star
                                        newRating = newRating == Int16(star) ? 0 : Int16(star)
                                    }) {
                                        Image(systemName: star <= newRating ? "star.fill" : "star")
                                            .foregroundColor(star <= newRating ? .orange : .gray)
                                            .font(.title2)
                                            .frame(width: 32, height: 32)
                                            .contentShape(Rectangle())
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            TextField("Write a comment...", text: $newComment, axis: .vertical)
                                .textFieldStyle(.roundedBorder)
                                .lineLimit(3...6)
                            Button("Post Comment") {
                                postComment()
                            }
                            .buttonStyle(.borderedProminent)
                            .disabled(newComment.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
                .padding()
            }
            .navigationTitle("Experience Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
    private func postComment() {
        viewModel.createComment(
            comment: newComment.trimmingCharacters(in: .whitespacesAndNewlines),
            rating: newRating,
            experience: experience,
            user: viewModel.getCurrentUser()
        )
        newComment = ""
        newRating = 0
    }
}
struct CommentView: View {
    let comment: UserComment
    let viewModel: SocialFeedViewModel
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(comment.user?.username ?? "Anonymous")
                    .font(.subheadline)
                    .fontWeight(.medium)
                Spacer()
                Text(viewModel.formatDate(comment.createdAt))
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            Text(comment.comment ?? "")
                .font(.body)
            if comment.rating > 0 {
                Text(viewModel.formatRating(comment.rating))
                    .font(.caption)
                    .foregroundColor(.orange)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(8)
    }
}
#Preview {
    SocialFeedView()
}
